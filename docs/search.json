[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "In this document, I will show you the programming languages that can be used in computing with the use of for loops and how to wrap them into R. And also, I will share you my experiences of using these languages.\nNote that not all the programming languages are listed and used in this documents. The programming languages listed and used in this document are all the programming languages I know where you can write a code within it, integrate, and call them into R.\nThis document is written in Quarto Website.\n(Still under construction)"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "In this document, I will show you the programming languages that can be used in computing with the use of for loops and how to wrap them into R. And also, I will share you my experiences of using these languages.\nNote that not all the programming languages are listed and used in this documents. The programming languages listed and used in this document are all the programming languages I know where you can write a code within it, integrate, and call them into R.\nThis document is written in Quarto Website.\n(Still under construction)"
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "I thought the outcome stays the same. Sometimes, when I make another run on approximating \\(\\pi\\), C is the fastest while sometimes FORTRAN is the fastest. Only if I make a Quarto Documentation out of this code, or otherwise, C++ is surely the fastest.\nThe remarks that I am sure for this example:\n\nR or Python shares the outcome: Being the slowest among them.\nThe Rust code is just not optimized.\n\nSame thing for other languages, especially Julia.\n\nC++ is the fastest in some application here.\n\nRecursive Fibonacci Sequence\n\n\nSo here’s my take:\n\nSurely that C++ code is only code that can make R code faster. Among the lower languages, C++ is the easiest language to compile but you need to write a boilerplate C++ code in order to work.\nFORTRAN code makes the solution the more boilerplate.\nUse vectorized operations or parallel computing to make the code more faster.",
    "crumbs": [
      "Home",
      "Conclusion",
      "Conclusion"
    ]
  },
  {
    "objectID": "conclusion.html#conclusion",
    "href": "conclusion.html#conclusion",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "I thought the outcome stays the same. Sometimes, when I make another run on approximating \\(\\pi\\), C is the fastest while sometimes FORTRAN is the fastest. Only if I make a Quarto Documentation out of this code, or otherwise, C++ is surely the fastest.\nThe remarks that I am sure for this example:\n\nR or Python shares the outcome: Being the slowest among them.\nThe Rust code is just not optimized.\n\nSame thing for other languages, especially Julia.\n\nC++ is the fastest in some application here.\n\nRecursive Fibonacci Sequence\n\n\nSo here’s my take:\n\nSurely that C++ code is only code that can make R code faster. Among the lower languages, C++ is the easiest language to compile but you need to write a boilerplate C++ code in order to work.\nFORTRAN code makes the solution the more boilerplate.\nUse vectorized operations or parallel computing to make the code more faster.",
    "crumbs": [
      "Home",
      "Conclusion",
      "Conclusion"
    ]
  },
  {
    "objectID": "4 - moving_average.html",
    "href": "4 - moving_average.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "set.seed(123)\nzz &lt;- rnorm(1e4, mean = 10, sd = 1.5)\n\nFor the languages that are strict to the data types (which in this case, Julia, Rust, and Python), I cannot run their functions if the array argument is not double and the window size argument is not an integer. That’s why, I need to convert the array into double and I need to put L followed from number so that the number becomes strictly integer.\n\nCC++JuliaRustFORTRANRPython\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid moving_ave_c(double *x, int *n, int *window_size, double *moving_averages) {\n    int result_size = *n - *window_size + 1;\n    double *paddedX = (double *)malloc(result_size * sizeof(double));\n\n    if (paddedX == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        free(paddedX);\n        return;\n    }\n\n    for (int i = 0; i &lt; result_size; i++) {\n        moving_averages[i] = 0;\n        for (int j = 0; j &lt; *window_size; j++) {\n            moving_averages[i] += x[i + j];\n        }\n        moving_averages[i] /= *window_size;\n    }\n\n    free(paddedX);\n}\n\n\nmoving_ave_c &lt;- function(x, window_size) {\n     result_size &lt;- length(x) - window_size + 1\n     moving_averages &lt;- double(result_size)\n     moving_averages &lt;- .C(\"moving_ave_c\",\n                           as.double(x), as.integer(length(x)), as.integer(window_size),\n                           moving_averages = double(result_size))$moving_averages\n     return(moving_averages)\n}\n\nmoving_ave_c(1:10, 3)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector moving_ave_cpp(NumericVector x, int window_size) {\n  int n = x.size();\n  int result_size = n - window_size + 1;\n  NumericVector moving_averages(result_size);\n  \n  double sum = 0.0;\n  for (int j = 0; j &lt; window_size; j++) {\n    sum += x[j];\n  }\n  moving_averages[0] = sum / window_size;\n  \n  for (int i = 1; i &lt; result_size; i++) {\n    sum += x[i + window_size - 1] - x[i - 1];\n    moving_averages[i] = sum / window_size;\n  }\n  \n  return moving_averages;\n}\n\n\n\n\nfunction moving_ave_julia(x::Vector{Float64}, n::Int)\n    len = length(x)\n    moving_averages = Vector{Float64}(undef, len - n + 1)\n    \n    for i in 1:len - n + 1\n        window_sum = sum(x[i:i+n-1])\n        moving_averages[i] = round(window_sum / n, digits=2)\n    end\n    \n    return moving_averages\nend\n\nmoving_ave_julia (generic function with 1 method)\n\n\n\nmoving_ave_jl &lt;- JuliaCall::julia_eval(\"moving_ave_julia\")\nmoving_ave_jl(as.double(1:10), 3L)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn moving_ave_rs(x: Vec&lt;f64&gt;, n: i32) -&gt; Vec&lt;f64&gt; {\n    let len = x.len();\n    let mut moving_averages = Vec::with_capacity(len - n as usize + 1);\n\n    for i in 0..=len - n as usize {\n        let window_sum: f64 = x[i..i + n as usize].iter().sum();\n        moving_averages.push(window_sum / n as f64);\n    }\n\n    moving_averages.iter().map(|&x| (x * 100.0).round() / 100.0).collect()\n}\n\n\nmoving_ave_rs(as.double(1:10), 3L)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\nsubroutine moving_ave_f(x, n, window_size, moving_averages)\n    implicit none\n    integer, intent(in) :: n, window_size\n    double precision, intent(in) :: x(n)\n    double precision, intent(out) :: moving_averages(n - window_size + 1)\n    integer :: i, j\n    double precision :: sum\n\n    do i = 1, n - window_size + 1\n        sum = 0.0d0\n        do j = i, i + window_size - 1\n            sum = sum + x(j)\n        end do\n        moving_averages(i) = sum / window_size\n    end do\n\nend subroutine moving_ave_f\n\n\nmoving_ave_fortran &lt;- function(x, window_size) {\n     result_size &lt;- length(x) - window_size + 1\n     moving_averages &lt;- double(result_size)\n     moving_averages &lt;- .Fortran(\"moving_ave_f\",\n                           as.double(x), as.integer(length(x)), as.integer(window_size),\n                           moving_averages = double(result_size))$moving_averages\n     return(moving_averages)\n}\n\nmoving_ave_fortran(1:10, 3)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\nmoving_ave_r &lt;- function(x, n) {\n    moving_averages &lt;- numeric(length(x) - n + 1)\n    \n    for (i in 1:(length(x) - n + 1)) {\n        moving_averages[i] &lt;- sum(x[i:(i + n - 1)]) / n\n    }\n    \n    return(round(moving_averages, 2))\n}\n\nmoving_ave_r(1:10, 3)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\ndef moving_ave_py(arr, window_size):\n    i = 0\n    # Initialize an empty list to store moving averages\n    moving_averages = []\n\n    # Loop through the array to consider\n    # every window of size 'window_size'\n    while i &lt; len(arr) - window_size + 1:\n\n        # Store elements from i to i+window_size\n        # in list to get the current window\n        window = arr[i : i + window_size]\n\n        # Calculate the average of the current window\n        window_average = round(sum(window) / window_size, 2)\n\n        # Store the average of the current window in the moving average list\n        moving_averages.append(window_average)\n\n        # Shift the window to the right by one position\n        i += 1\n\n    return moving_averages\n\n\nmoving_ave_py &lt;- reticulate::py$moving_ave_py\nmoving_ave_py(as.double(1:10), 3L)\n\n[1] 2 3 4 5 6 7 8 9",
    "crumbs": [
      "Home",
      "Moving Average",
      "4.1 Moving Average"
    ]
  },
  {
    "objectID": "4 - moving_average.html#moving-average",
    "href": "4 - moving_average.html#moving-average",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "set.seed(123)\nzz &lt;- rnorm(1e4, mean = 10, sd = 1.5)\n\nFor the languages that are strict to the data types (which in this case, Julia, Rust, and Python), I cannot run their functions if the array argument is not double and the window size argument is not an integer. That’s why, I need to convert the array into double and I need to put L followed from number so that the number becomes strictly integer.\n\nCC++JuliaRustFORTRANRPython\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid moving_ave_c(double *x, int *n, int *window_size, double *moving_averages) {\n    int result_size = *n - *window_size + 1;\n    double *paddedX = (double *)malloc(result_size * sizeof(double));\n\n    if (paddedX == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        free(paddedX);\n        return;\n    }\n\n    for (int i = 0; i &lt; result_size; i++) {\n        moving_averages[i] = 0;\n        for (int j = 0; j &lt; *window_size; j++) {\n            moving_averages[i] += x[i + j];\n        }\n        moving_averages[i] /= *window_size;\n    }\n\n    free(paddedX);\n}\n\n\nmoving_ave_c &lt;- function(x, window_size) {\n     result_size &lt;- length(x) - window_size + 1\n     moving_averages &lt;- double(result_size)\n     moving_averages &lt;- .C(\"moving_ave_c\",\n                           as.double(x), as.integer(length(x)), as.integer(window_size),\n                           moving_averages = double(result_size))$moving_averages\n     return(moving_averages)\n}\n\nmoving_ave_c(1:10, 3)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector moving_ave_cpp(NumericVector x, int window_size) {\n  int n = x.size();\n  int result_size = n - window_size + 1;\n  NumericVector moving_averages(result_size);\n  \n  double sum = 0.0;\n  for (int j = 0; j &lt; window_size; j++) {\n    sum += x[j];\n  }\n  moving_averages[0] = sum / window_size;\n  \n  for (int i = 1; i &lt; result_size; i++) {\n    sum += x[i + window_size - 1] - x[i - 1];\n    moving_averages[i] = sum / window_size;\n  }\n  \n  return moving_averages;\n}\n\n\n\n\nfunction moving_ave_julia(x::Vector{Float64}, n::Int)\n    len = length(x)\n    moving_averages = Vector{Float64}(undef, len - n + 1)\n    \n    for i in 1:len - n + 1\n        window_sum = sum(x[i:i+n-1])\n        moving_averages[i] = round(window_sum / n, digits=2)\n    end\n    \n    return moving_averages\nend\n\nmoving_ave_julia (generic function with 1 method)\n\n\n\nmoving_ave_jl &lt;- JuliaCall::julia_eval(\"moving_ave_julia\")\nmoving_ave_jl(as.double(1:10), 3L)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn moving_ave_rs(x: Vec&lt;f64&gt;, n: i32) -&gt; Vec&lt;f64&gt; {\n    let len = x.len();\n    let mut moving_averages = Vec::with_capacity(len - n as usize + 1);\n\n    for i in 0..=len - n as usize {\n        let window_sum: f64 = x[i..i + n as usize].iter().sum();\n        moving_averages.push(window_sum / n as f64);\n    }\n\n    moving_averages.iter().map(|&x| (x * 100.0).round() / 100.0).collect()\n}\n\n\nmoving_ave_rs(as.double(1:10), 3L)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\nsubroutine moving_ave_f(x, n, window_size, moving_averages)\n    implicit none\n    integer, intent(in) :: n, window_size\n    double precision, intent(in) :: x(n)\n    double precision, intent(out) :: moving_averages(n - window_size + 1)\n    integer :: i, j\n    double precision :: sum\n\n    do i = 1, n - window_size + 1\n        sum = 0.0d0\n        do j = i, i + window_size - 1\n            sum = sum + x(j)\n        end do\n        moving_averages(i) = sum / window_size\n    end do\n\nend subroutine moving_ave_f\n\n\nmoving_ave_fortran &lt;- function(x, window_size) {\n     result_size &lt;- length(x) - window_size + 1\n     moving_averages &lt;- double(result_size)\n     moving_averages &lt;- .Fortran(\"moving_ave_f\",\n                           as.double(x), as.integer(length(x)), as.integer(window_size),\n                           moving_averages = double(result_size))$moving_averages\n     return(moving_averages)\n}\n\nmoving_ave_fortran(1:10, 3)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\nmoving_ave_r &lt;- function(x, n) {\n    moving_averages &lt;- numeric(length(x) - n + 1)\n    \n    for (i in 1:(length(x) - n + 1)) {\n        moving_averages[i] &lt;- sum(x[i:(i + n - 1)]) / n\n    }\n    \n    return(round(moving_averages, 2))\n}\n\nmoving_ave_r(1:10, 3)\n\n[1] 2 3 4 5 6 7 8 9\n\n\n\n\n\ndef moving_ave_py(arr, window_size):\n    i = 0\n    # Initialize an empty list to store moving averages\n    moving_averages = []\n\n    # Loop through the array to consider\n    # every window of size 'window_size'\n    while i &lt; len(arr) - window_size + 1:\n\n        # Store elements from i to i+window_size\n        # in list to get the current window\n        window = arr[i : i + window_size]\n\n        # Calculate the average of the current window\n        window_average = round(sum(window) / window_size, 2)\n\n        # Store the average of the current window in the moving average list\n        moving_averages.append(window_average)\n\n        # Shift the window to the right by one position\n        i += 1\n\n    return moving_averages\n\n\nmoving_ave_py &lt;- reticulate::py$moving_ave_py\nmoving_ave_py(as.double(1:10), 3L)\n\n[1] 2 3 4 5 6 7 8 9",
    "crumbs": [
      "Home",
      "Moving Average",
      "4.1 Moving Average"
    ]
  },
  {
    "objectID": "4 - moving_average.html#benchmark",
    "href": "4 - moving_average.html#benchmark",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "Benchmark",
    "text": "Benchmark\n\nbench::mark(\n    C = moving_ave_c(zz, 10),\n    `C++` = moving_ave_cpp(zz, 10),\n    Julia = moving_ave_jl(zz, 10L),\n    Rust = moving_ave_rs(zz, 10L),\n    FORTRAN = moving_ave_fortran(zz, 10),\n    R = moving_ave_r(zz, 10),\n    Python = moving_ave_py(zz, 10L),\n    check = F\n)\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C           140.4µs  425.4µs    2018.    351.1KB    18.0 \n2 C++          21.8µs   79.4µs   11241.     80.6KB    23.8 \n3 Julia        1.36ms    1.6ms     454.     83.8KB     2.03\n4 Rust            2ms   2.75ms     306.       83KB     0   \n5 FORTRAN     117.1µs  453.6µs    1947.    351.1KB    17.3 \n6 R            7.58ms  14.13ms      56.2   156.2KB     9.78\n7 Python      15.19ms  22.08ms      40.2    83.1KB     0",
    "crumbs": [
      "Home",
      "Moving Average",
      "4.1 Moving Average"
    ]
  },
  {
    "objectID": "2 - pi_approx.html",
    "href": "2 - pi_approx.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "It took hundreds of years to precisely approximate the \\(\\pi\\).\nI used the Leibniz formula to approximate \\(\\pi\\). It came from an alternating series, a power series of \\(\\frac{1}{x^2+1}\\).\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 0}^{\\infty} {\\frac{(-1)^k}{2k + 1}}\n\\]\nWe need to adjust a little bit for the programming languages that starts with index-1, namely R, Julia and FORTRAN.\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 1}^{\\infty} {\\frac{(-1)^k}{2k - 1}}\n\\]\n\nCC++JuliaRustFORTRANRPython\n\n\nIf your purpose is a language for fast computation within R, C is maybe easier than C++ but in order this to be working and exportable, the inputs and outputs of the computation were stored in the memory address, a.k.a. the pointers.\n\n#include &lt;stdio.h&gt;\n\nvoid pi_approx_c(int *n, double *result) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; *n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  *result = 4 * pi_4;\n}\n\nIn order to wrap the C code into R, use .C and then extract the result via $res.\n\npi_approx_c &lt;- function(n) {\n  res &lt;- .C(\"pi_approx_c\", as.integer(n), res=numeric(1))$res\n  return(res)\n}\n\npi_approx_c(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, the C++ code is way similar to the C code except, we don’t need to use pointers in order share the results in a memory address, instead we only write the C++ code in a standard way. Like I said, using Rcpp, the C++ code is so easy to be exported, as long as we made it to be error-free.\nAfter compiling, the pi_approx_cpp function will be exported by // [[Rcpp::export]] attributes and saved into R Global Environment directly.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble pi_approx_cpp(int& n) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  return 4 * pi_4;\n}\n\nThe C++’s pi_approx_cpp is directly wrapped into R environment without doing an execution to convert the C++ code into binary source code.\n\npi_approx_cpp(1e5)\n\n[1] 3.141583\n\n\n\n\nAs you can see, we only write few codes, unlike in C/C++, to approximate the \\(\\pi\\)\n\nfunction pi_approx_jl(n)\n    pi_4 = 0.0\n    sign = 1.0\n    for i in 1:n\n        pi_4 += sign / (2*i - 1)\n        sign *= -1\n    end\n    return 4 * pi_4\nend\n\nTo prove that the Julia functioncode is executed, you will receive a message “pi_approx_jl (generic function with 1 method)”. And you are now ready to wrap it into R.\nWith JuliaCall, you can wrap the Julia function into R via julia_eval. But there are few other ways to call it, but I found julia_eval more convenient.\n(Note: If you are already familiar with reticulate, this is the same as py_eval)\n\npi_approx_jl &lt;- JuliaCall::julia_eval(\"pi_approx_jl\")\npi_approx_jl(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, we use the extendr and #[extendr] attribute API to write a Rust code and compile it into R, just like we did with Rcpp to compile the C++ code into R\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn pi_approx_rs(n: i32) -&gt; f64 {\n    let mut pi_4 = 0.0;\n    let mut sign = 1.0;\n\n    for i in 0..n {\n        pi_4 += sign / (2 * i + 1) as f64;\n        sign *= -1.0;\n    }\n\n    4.0 * pi_4\n}\n\nAfter compiling, just like C++, the pi_approx_rs function in Rust will be wrapped and saved into R Global Environment directly.\n\npi_approx_rs(1e5)\n\n[1] 3.141583\n\n\n\n\nMaybe FORTRAN is fast, but the solution is more boilerplate, although for me it is more readable compared to C/C++. Just like C, we need the result to be store in memory address.\nIf you use old FORTRAN version, you might need to CAPITALIZE the FORTRAN program. But we use the ’95 version of FORTRAN so we don’t need to CAPITALIZE the program.\n(It is still a code block even if the FORTRAN code is text-based)\n\nsubroutine pi_approx(n, result)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: result\n    integer :: i\n    real(8) :: pi_4, sign\n    \n    pi_4 = 0.0\n    sign = 1.0\n    \n    do i = 1, n\n        pi_4 = pi_4 + sign / (2 * i - 1)\n        sign = sign * (-1.0)\n    end do\n    \n    result = 4 * pi_4\nend subroutine pi_approx\n\nJust like C, but instead, in order to natively call the FORTRAN code into R, use .Fortran to call the binary source code of FORTRAN’s pi_approx and then extract the result via $result.\n\npi_approx_fortran &lt;- function(n) {\n  result &lt;- .Fortran(\"pi_approx\", as.integer(n), result=double(1))$result\n  return(result)\n}\n\npi_approx_fortran(1e5)\n\n[1] 3.141583\n\n\n\n\nR is so close to be functional programming and to be Domain Specific Language (or DSL). It is so functional, you need to use &lt;- function() to define a function and I sometimes agree that this is ugly but hey it works! This is just my opinion.\nR is already a default language in RStudio, so the function we define is already callable in R Global Environment.\n\npi_approx_r &lt;- function(n) {\n  pi_4 &lt;- 0\n  sign &lt;- 1\n  \n  for (i in 1:n) {\n    pi_4 &lt;- pi_4 + sign / (2*i - 1)\n    sign &lt;- sign * -1\n  }\n  \n  return(4 * pi_4)\n}\n\npi_approx_r(1e5)\n\n[1] 3.141583\n\n\n\n\nR and Python has so much similarities, except Python is more onto general purpose language.\n\ndef pi_approx_py(n):\n    n = int(n)\n    pi_4 = 0\n    sign = 1\n    \n    for i in range(n):\n        pi_4 += sign / (2 * i + 1)\n        sign *= -1\n    return pi_4 * 4\n\nThe defined function in Python is also callable. Using py module in reticulate package, you can easily interact with any Python objects in Python module.\n\npi_approx_py &lt;- reticulate::py$pi_approx_py\npi_approx_py(1e5)\n\n[1] 3.141583",
    "crumbs": [
      "Home",
      "Approximating Pi",
      "2.1 Approximating $\\pi$"
    ]
  },
  {
    "objectID": "2 - pi_approx.html#approximating-pi",
    "href": "2 - pi_approx.html#approximating-pi",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "It took hundreds of years to precisely approximate the \\(\\pi\\).\nI used the Leibniz formula to approximate \\(\\pi\\). It came from an alternating series, a power series of \\(\\frac{1}{x^2+1}\\).\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 0}^{\\infty} {\\frac{(-1)^k}{2k + 1}}\n\\]\nWe need to adjust a little bit for the programming languages that starts with index-1, namely R, Julia and FORTRAN.\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 1}^{\\infty} {\\frac{(-1)^k}{2k - 1}}\n\\]\n\nCC++JuliaRustFORTRANRPython\n\n\nIf your purpose is a language for fast computation within R, C is maybe easier than C++ but in order this to be working and exportable, the inputs and outputs of the computation were stored in the memory address, a.k.a. the pointers.\n\n#include &lt;stdio.h&gt;\n\nvoid pi_approx_c(int *n, double *result) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; *n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  *result = 4 * pi_4;\n}\n\nIn order to wrap the C code into R, use .C and then extract the result via $res.\n\npi_approx_c &lt;- function(n) {\n  res &lt;- .C(\"pi_approx_c\", as.integer(n), res=numeric(1))$res\n  return(res)\n}\n\npi_approx_c(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, the C++ code is way similar to the C code except, we don’t need to use pointers in order share the results in a memory address, instead we only write the C++ code in a standard way. Like I said, using Rcpp, the C++ code is so easy to be exported, as long as we made it to be error-free.\nAfter compiling, the pi_approx_cpp function will be exported by // [[Rcpp::export]] attributes and saved into R Global Environment directly.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble pi_approx_cpp(int& n) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  return 4 * pi_4;\n}\n\nThe C++’s pi_approx_cpp is directly wrapped into R environment without doing an execution to convert the C++ code into binary source code.\n\npi_approx_cpp(1e5)\n\n[1] 3.141583\n\n\n\n\nAs you can see, we only write few codes, unlike in C/C++, to approximate the \\(\\pi\\)\n\nfunction pi_approx_jl(n)\n    pi_4 = 0.0\n    sign = 1.0\n    for i in 1:n\n        pi_4 += sign / (2*i - 1)\n        sign *= -1\n    end\n    return 4 * pi_4\nend\n\nTo prove that the Julia functioncode is executed, you will receive a message “pi_approx_jl (generic function with 1 method)”. And you are now ready to wrap it into R.\nWith JuliaCall, you can wrap the Julia function into R via julia_eval. But there are few other ways to call it, but I found julia_eval more convenient.\n(Note: If you are already familiar with reticulate, this is the same as py_eval)\n\npi_approx_jl &lt;- JuliaCall::julia_eval(\"pi_approx_jl\")\npi_approx_jl(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, we use the extendr and #[extendr] attribute API to write a Rust code and compile it into R, just like we did with Rcpp to compile the C++ code into R\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn pi_approx_rs(n: i32) -&gt; f64 {\n    let mut pi_4 = 0.0;\n    let mut sign = 1.0;\n\n    for i in 0..n {\n        pi_4 += sign / (2 * i + 1) as f64;\n        sign *= -1.0;\n    }\n\n    4.0 * pi_4\n}\n\nAfter compiling, just like C++, the pi_approx_rs function in Rust will be wrapped and saved into R Global Environment directly.\n\npi_approx_rs(1e5)\n\n[1] 3.141583\n\n\n\n\nMaybe FORTRAN is fast, but the solution is more boilerplate, although for me it is more readable compared to C/C++. Just like C, we need the result to be store in memory address.\nIf you use old FORTRAN version, you might need to CAPITALIZE the FORTRAN program. But we use the ’95 version of FORTRAN so we don’t need to CAPITALIZE the program.\n(It is still a code block even if the FORTRAN code is text-based)\n\nsubroutine pi_approx(n, result)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: result\n    integer :: i\n    real(8) :: pi_4, sign\n    \n    pi_4 = 0.0\n    sign = 1.0\n    \n    do i = 1, n\n        pi_4 = pi_4 + sign / (2 * i - 1)\n        sign = sign * (-1.0)\n    end do\n    \n    result = 4 * pi_4\nend subroutine pi_approx\n\nJust like C, but instead, in order to natively call the FORTRAN code into R, use .Fortran to call the binary source code of FORTRAN’s pi_approx and then extract the result via $result.\n\npi_approx_fortran &lt;- function(n) {\n  result &lt;- .Fortran(\"pi_approx\", as.integer(n), result=double(1))$result\n  return(result)\n}\n\npi_approx_fortran(1e5)\n\n[1] 3.141583\n\n\n\n\nR is so close to be functional programming and to be Domain Specific Language (or DSL). It is so functional, you need to use &lt;- function() to define a function and I sometimes agree that this is ugly but hey it works! This is just my opinion.\nR is already a default language in RStudio, so the function we define is already callable in R Global Environment.\n\npi_approx_r &lt;- function(n) {\n  pi_4 &lt;- 0\n  sign &lt;- 1\n  \n  for (i in 1:n) {\n    pi_4 &lt;- pi_4 + sign / (2*i - 1)\n    sign &lt;- sign * -1\n  }\n  \n  return(4 * pi_4)\n}\n\npi_approx_r(1e5)\n\n[1] 3.141583\n\n\n\n\nR and Python has so much similarities, except Python is more onto general purpose language.\n\ndef pi_approx_py(n):\n    n = int(n)\n    pi_4 = 0\n    sign = 1\n    \n    for i in range(n):\n        pi_4 += sign / (2 * i + 1)\n        sign *= -1\n    return pi_4 * 4\n\nThe defined function in Python is also callable. Using py module in reticulate package, you can easily interact with any Python objects in Python module.\n\npi_approx_py &lt;- reticulate::py$pi_approx_py\npi_approx_py(1e5)\n\n[1] 3.141583",
    "crumbs": [
      "Home",
      "Approximating Pi",
      "2.1 Approximating $\\pi$"
    ]
  },
  {
    "objectID": "2 - pi_approx.html#benchmarks",
    "href": "2 - pi_approx.html#benchmarks",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "Benchmarks",
    "text": "Benchmarks\nThe benchmarks are the same when I capture the date and time, similar to Sys.time in R. For example, when I run the Python code for \\(\\pi\\) approximation (same code as example) and benchmark it with time module for the first time, I got a difference of 17 seconds. Plus, the mark function from bench package is so precise that I use this package everytime when I benchmark the codes.\n\npi_approx_bm &lt;- bench::mark(\n  C = pi_approx_c(1e8),\n  `C++` = pi_approx_cpp(1e8),\n  Julia = pi_approx_jl(1e8),\n  Rust = pi_approx_rs(1e8),\n  FORTRAN = pi_approx_fortran(1e8),\n  R = pi_approx_r(1e8),\n  Python = pi_approx_py(1e8),\n  check = F\n)\npi_approx_bm\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C           164.6ms  186.2ms    5.47     16.46KB        0\n2 C++         170.8ms  187.1ms    5.46      7.67KB        0\n3 Julia       542.9ms  542.9ms    1.84      5.73KB        0\n4 Rust           1.4s     1.4s    0.713      4.8KB        0\n5 FORTRAN     179.4ms  188.6ms    5.28     16.46KB        0\n6 R             23.1s    23.1s    0.0433        0B        0\n7 Python        55.6s    55.6s    0.0180    4.98KB        0\n\npi_approx_bm |&gt; plot()\n\nLoading required namespace: tidyr\n\n\n\n\n\n\n\n\n\nFrom this result, we can say that the C++ is the fastest language among the 7 languages I selected for computing in using for loops, following with C and FORTRAN.",
    "crumbs": [
      "Home",
      "Approximating Pi",
      "2.1 Approximating $\\pi$"
    ]
  },
  {
    "objectID": "1 - intro.html",
    "href": "1 - intro.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "As I said in the introduction, these are only the list where you can integrate into R.\nHere are the list of languages will be used in this document:\n\nC\n\nFirst released in 1970s.\nC is maybe the easiest compiled language to learn that is used for Operating Systems. It is so easy to compile a C code to R.\nIn order to compile C in R, you need to convert the C code into a binary source code and then you can call it using .C.\nUsage:\ngcc -shared -o foo.so foo.c\nThis is more easier:\nR CMD SHLIB foo.c\nPersonal Experience:\n\na year\nC is hard for me to write.\n\n\nC++\n\nAn extension to C.\nDespite its reputation for complexity, leveraging tools like Rcpp and its APIs makes writing C++ code more accessible. Plus, exporting C++ code into the R environment is a breeze, even I, who sometimes write a bad code, can write a C++ code and it is so easy to export a C++ code into R environment.\nCompared to C, compilation in C++ might take a bit longer due to various factors.\nDownload Rcpp and its necessary build tools first. With the Rcpp namespace, you can seamlessly integrate Rcpp (C++) features like NumericVector and DataFrame, mirroring R’s class system.\nPersonal Experience:\n\nA year.\nWith Rcpp, it became easy for me to learn this language but C++ is still hard for me.\nI am still rusty to write a code from this language at all.\n\n\nJulia\n\nJulia shares similarities with C in that it’s a compiled language, effectively addressing the “2 language problem” by eliminating the need for separate languages like C, C++, or FORTRAN APIs.\nJulia is a JIT compiled and it is able to be both fast and easy to read.\nNecessary tools: Julia and JuliaCall.\nPersonal Experience:\n\na year.\nGreat language but bothered to learn unless until I master R, Python, and C++.\n\n\nRust\n\nRust, akin to C/C++, prioritizes memory safety.\nPreparing to compile Rust code in R involves installing necessary package (i.e. extendr/rextendr), Build Tools and rustc and then install the cargo via the terminal.\nPersonal Experience:\n\nSince December 2023. If I remember it correctly, I was amazed by this language because of Polars library.\nI need to master R, Python, and C++ first, and then I won’t bother myself learn this language.\nInstallation is such a pain. If you ignore it, using Rust is such an amazing experience.\n\n\nFORTRAN\n\nDespite its age, FORTRAN remains indispensable in the realm of computing, boasting speed comparable to C/C++.\nIt’s still widely used as source code for R packages, fAsianOptions as its example.\nJust like C, in order to compile FORTRAN in R, you need to convert the FORTRAN code into a binary source code and then you can call it using .Fortran.\nUsage:\ngfortran -shared -o bar.so bar.f95\nJust as C, this is more easier:\nR CMD SHLIB bar.f95\nPersonal Experience:\n\nI learn this language recently when I learnt the history of R.\nSame as C but I’m bothered to learn it.\n\n\nR\n\nR is actually derived from S, a statistical programming language created by Bell Labs.\nWhile maybe R isn’t exclusively utilized for computing, it’s a statistical computing language widely embraced in statistical analysis.\nWith R, it is so easy to conduct a pure data science like data manipulation and visualizations, thanks to the libraries, such as dplyr and ggplot2, and to integrate “structured” databases with DBI and dbplyr.\nJust like Python, R is an interpreted language.\nTo use R and its IDE, RStudio, you need to download them first.\n\nR: https://cran.r-project.org/bin/windows/base/\nRStudio: https://posit.co/download/rstudio-desktop/\n\nPersonal Experience:\n\n3 years. Of course, I am a statistics student.\nI started learning this language way back when I was high school student, but started to re-learn this language when I study statistics.\n\n\nPython\n\nPython is an effective general purpose language that can be even used in statistics or any fields of computing.\nTo use Python in R, you need to install Python and reticulate first.\n\nIf you install Python from its webpage, configure the path into its system environment variables and then configure it into RStudio and simply call py_config and then put the path as its argument (you can configure it in Global Option, and then select Python and select the path according to what system detects for its interpreter).\n\n\n\nSource: RStudio User Guide\n\n\n)\nIf you install Python using install_python, it will automatically create a virtual environment (it is separated to the Python you installed into the System).\nSeparately to the system, you can install its conda environment conda_install.\n\nPersonal Experience:\n\n2 years.\nWhen I study statistics.\n\n\n\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. To be real, not all the programming languages listed here is what I can write by my own, they are FORTRAN, Rust, and C. Moreover, I only used those languages that can be both used in computing and listed in knitr. Also, you can wrap the functions from other languages and this is what I do so that it would be easy for me to benchmark them with bench::time.\nThe snippet were explained by comment blocks (#) in the code blocks.",
    "crumbs": [
      "Home",
      "Introduction",
      "1.1 Languages"
    ]
  },
  {
    "objectID": "1 - intro.html#languages",
    "href": "1 - intro.html#languages",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "As I said in the introduction, these are only the list where you can integrate into R.\nHere are the list of languages will be used in this document:\n\nC\n\nFirst released in 1970s.\nC is maybe the easiest compiled language to learn that is used for Operating Systems. It is so easy to compile a C code to R.\nIn order to compile C in R, you need to convert the C code into a binary source code and then you can call it using .C.\nUsage:\ngcc -shared -o foo.so foo.c\nThis is more easier:\nR CMD SHLIB foo.c\nPersonal Experience:\n\na year\nC is hard for me to write.\n\n\nC++\n\nAn extension to C.\nDespite its reputation for complexity, leveraging tools like Rcpp and its APIs makes writing C++ code more accessible. Plus, exporting C++ code into the R environment is a breeze, even I, who sometimes write a bad code, can write a C++ code and it is so easy to export a C++ code into R environment.\nCompared to C, compilation in C++ might take a bit longer due to various factors.\nDownload Rcpp and its necessary build tools first. With the Rcpp namespace, you can seamlessly integrate Rcpp (C++) features like NumericVector and DataFrame, mirroring R’s class system.\nPersonal Experience:\n\nA year.\nWith Rcpp, it became easy for me to learn this language but C++ is still hard for me.\nI am still rusty to write a code from this language at all.\n\n\nJulia\n\nJulia shares similarities with C in that it’s a compiled language, effectively addressing the “2 language problem” by eliminating the need for separate languages like C, C++, or FORTRAN APIs.\nJulia is a JIT compiled and it is able to be both fast and easy to read.\nNecessary tools: Julia and JuliaCall.\nPersonal Experience:\n\na year.\nGreat language but bothered to learn unless until I master R, Python, and C++.\n\n\nRust\n\nRust, akin to C/C++, prioritizes memory safety.\nPreparing to compile Rust code in R involves installing necessary package (i.e. extendr/rextendr), Build Tools and rustc and then install the cargo via the terminal.\nPersonal Experience:\n\nSince December 2023. If I remember it correctly, I was amazed by this language because of Polars library.\nI need to master R, Python, and C++ first, and then I won’t bother myself learn this language.\nInstallation is such a pain. If you ignore it, using Rust is such an amazing experience.\n\n\nFORTRAN\n\nDespite its age, FORTRAN remains indispensable in the realm of computing, boasting speed comparable to C/C++.\nIt’s still widely used as source code for R packages, fAsianOptions as its example.\nJust like C, in order to compile FORTRAN in R, you need to convert the FORTRAN code into a binary source code and then you can call it using .Fortran.\nUsage:\ngfortran -shared -o bar.so bar.f95\nJust as C, this is more easier:\nR CMD SHLIB bar.f95\nPersonal Experience:\n\nI learn this language recently when I learnt the history of R.\nSame as C but I’m bothered to learn it.\n\n\nR\n\nR is actually derived from S, a statistical programming language created by Bell Labs.\nWhile maybe R isn’t exclusively utilized for computing, it’s a statistical computing language widely embraced in statistical analysis.\nWith R, it is so easy to conduct a pure data science like data manipulation and visualizations, thanks to the libraries, such as dplyr and ggplot2, and to integrate “structured” databases with DBI and dbplyr.\nJust like Python, R is an interpreted language.\nTo use R and its IDE, RStudio, you need to download them first.\n\nR: https://cran.r-project.org/bin/windows/base/\nRStudio: https://posit.co/download/rstudio-desktop/\n\nPersonal Experience:\n\n3 years. Of course, I am a statistics student.\nI started learning this language way back when I was high school student, but started to re-learn this language when I study statistics.\n\n\nPython\n\nPython is an effective general purpose language that can be even used in statistics or any fields of computing.\nTo use Python in R, you need to install Python and reticulate first.\n\nIf you install Python from its webpage, configure the path into its system environment variables and then configure it into RStudio and simply call py_config and then put the path as its argument (you can configure it in Global Option, and then select Python and select the path according to what system detects for its interpreter).\n\n\n\nSource: RStudio User Guide\n\n\n)\nIf you install Python using install_python, it will automatically create a virtual environment (it is separated to the Python you installed into the System).\nSeparately to the system, you can install its conda environment conda_install.\n\nPersonal Experience:\n\n2 years.\nWhen I study statistics.\n\n\n\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. To be real, not all the programming languages listed here is what I can write by my own, they are FORTRAN, Rust, and C. Moreover, I only used those languages that can be both used in computing and listed in knitr. Also, you can wrap the functions from other languages and this is what I do so that it would be easy for me to benchmark them with bench::time.\nThe snippet were explained by comment blocks (#) in the code blocks.",
    "crumbs": [
      "Home",
      "Introduction",
      "1.1 Languages"
    ]
  },
  {
    "objectID": "3 - fib.html",
    "href": "3 - fib.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "Same procedure as approximating the \\(\\pi\\), compile and then compile\n\nCC++JuliaRustFORTRANRPython\n\n\n\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt;\n\nvoid fib_c(int *n, int *seq) {\n    seq[0] = 0;\n    if (*n &gt; 0) {\n        seq[1] = 1;\n        for (int i = 2; i &lt;= *n; ++i) {\n            seq[i] = seq[i - 1] + seq[i - 2];\n        }\n    }\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c1a9c52b064a9.c -o c1a9c52b064a9.o\ngcc -shared -s -static-libgcc -o c1a9c52b064a9.dll tmp.def c1a9c52b064a9.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_c &lt;- function(n) {\n  seq &lt;- integer(n + 1)\n  .C(\"fib_c\", n = as.integer(n), seq = as.integer(seq))$seq\n}\nfib_c(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector fib_cpp(int n){\n  IntegerVector fibSequence(n + 1);\n  fibSequence[0] = 0;\n  if (n &gt; 1) {\n    fibSequence[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n  }\n  return fibSequence;\n  \n}\n\n\n/***R\nfib_cpp(10)\n*/\n\n\n\n\nfunction fib_jl(n::Int)\n  fib = Int[]\n  push!(fib, 0)  \n  push!(fib, 1)  \n  \n  \n  for i in 3:n\n      push!(fib, fib[i - 1] + fib[i - 2])  \n  end\n  \n  return fib\nend\n\nfib_jl (generic function with 1 method)\n\n\n\nfib_jl &lt;- JuliaCall::julia_eval(\"fib_jl\")\nfib_jl(10L)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\n\n\n\nuse extendr_api::prelude::*;\nuse std::collections::HashMap;\n\nfn fibonacci(n: i32, memo: &mut HashMap&lt;i32, i32&gt;) -&gt; i32 {\n    if let Some(&result) = memo.get(&n) {\n        return result;\n    }\n\n    let result = if n &lt;= 1 {\n        n\n    } else {\n        fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    };\n\n    memo.insert(n, result);\n    result\n}\n\n#[extendr]\nfn fib_rs(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut sequence = vec![];\n    let mut memo = HashMap::new();\n\n    for i in 0..n + 1 {\n        sequence.push(fibonacci(i, &mut memo));\n    }\n\n    sequence\n}\n\n\nfib_rs(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nsubroutine fib_f(n, fib)\n    integer, intent(in) :: n\n    integer, intent(out) :: fib(n)\n    integer :: i\n    \n    fib(1) = 0\n    fib(2) = 1\n\n    do i = 3, n + 1\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\nend subroutine fib_f\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f951a9c4ac17bef.f95 -o f951a9c4ac17bef.o\ngcc -shared -s -static-libgcc -o f951a9c4ac17bef.dll tmp.def f951a9c4ac17bef.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_fortran &lt;- function(n) {\n  n &lt;- n + 1\n  .Fortran(\"fib_f\", as.integer(n), fib = integer(n))$fib\n}\nfib_fortran(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nfib_r &lt;- function(n) {\n  fib &lt;- integer(n + 1)\n  fib[1] &lt;- 0\n  fib[2] &lt;- 1\n  for (i in 3:(n+1)) {\n    fib[i] &lt;- fib[i - 1] + fib[i - 2]\n  }\n  return(fib)\n}\n\nfib_r(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\ndef fib_p(n):\n    n = int(n)\n    fib_seq = [0, 1]\n    for i in range(2, n + 1):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\n\nfib_py &lt;- reticulate::py$fib_p\nfib_py(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55",
    "crumbs": [
      "Home",
      "Recursive Fibonacci Sequence",
      "3.1 Recursive Fibonacci Sequence"
    ]
  },
  {
    "objectID": "3 - fib.html#recursive-fibonacci-sequence",
    "href": "3 - fib.html#recursive-fibonacci-sequence",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "Same procedure as approximating the \\(\\pi\\), compile and then compile\n\nCC++JuliaRustFORTRANRPython\n\n\n\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt;\n\nvoid fib_c(int *n, int *seq) {\n    seq[0] = 0;\n    if (*n &gt; 0) {\n        seq[1] = 1;\n        for (int i = 2; i &lt;= *n; ++i) {\n            seq[i] = seq[i - 1] + seq[i - 2];\n        }\n    }\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c1a9c52b064a9.c -o c1a9c52b064a9.o\ngcc -shared -s -static-libgcc -o c1a9c52b064a9.dll tmp.def c1a9c52b064a9.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_c &lt;- function(n) {\n  seq &lt;- integer(n + 1)\n  .C(\"fib_c\", n = as.integer(n), seq = as.integer(seq))$seq\n}\nfib_c(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector fib_cpp(int n){\n  IntegerVector fibSequence(n + 1);\n  fibSequence[0] = 0;\n  if (n &gt; 1) {\n    fibSequence[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n  }\n  return fibSequence;\n  \n}\n\n\n/***R\nfib_cpp(10)\n*/\n\n\n\n\nfunction fib_jl(n::Int)\n  fib = Int[]\n  push!(fib, 0)  \n  push!(fib, 1)  \n  \n  \n  for i in 3:n\n      push!(fib, fib[i - 1] + fib[i - 2])  \n  end\n  \n  return fib\nend\n\nfib_jl (generic function with 1 method)\n\n\n\nfib_jl &lt;- JuliaCall::julia_eval(\"fib_jl\")\nfib_jl(10L)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\n\n\n\nuse extendr_api::prelude::*;\nuse std::collections::HashMap;\n\nfn fibonacci(n: i32, memo: &mut HashMap&lt;i32, i32&gt;) -&gt; i32 {\n    if let Some(&result) = memo.get(&n) {\n        return result;\n    }\n\n    let result = if n &lt;= 1 {\n        n\n    } else {\n        fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    };\n\n    memo.insert(n, result);\n    result\n}\n\n#[extendr]\nfn fib_rs(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut sequence = vec![];\n    let mut memo = HashMap::new();\n\n    for i in 0..n + 1 {\n        sequence.push(fibonacci(i, &mut memo));\n    }\n\n    sequence\n}\n\n\nfib_rs(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nsubroutine fib_f(n, fib)\n    integer, intent(in) :: n\n    integer, intent(out) :: fib(n)\n    integer :: i\n    \n    fib(1) = 0\n    fib(2) = 1\n\n    do i = 3, n + 1\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\nend subroutine fib_f\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f951a9c4ac17bef.f95 -o f951a9c4ac17bef.o\ngcc -shared -s -static-libgcc -o f951a9c4ac17bef.dll tmp.def f951a9c4ac17bef.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_fortran &lt;- function(n) {\n  n &lt;- n + 1\n  .Fortran(\"fib_f\", as.integer(n), fib = integer(n))$fib\n}\nfib_fortran(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nfib_r &lt;- function(n) {\n  fib &lt;- integer(n + 1)\n  fib[1] &lt;- 0\n  fib[2] &lt;- 1\n  for (i in 3:(n+1)) {\n    fib[i] &lt;- fib[i - 1] + fib[i - 2]\n  }\n  return(fib)\n}\n\nfib_r(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\ndef fib_p(n):\n    n = int(n)\n    fib_seq = [0, 1]\n    for i in range(2, n + 1):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\n\nfib_py &lt;- reticulate::py$fib_p\nfib_py(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55",
    "crumbs": [
      "Home",
      "Recursive Fibonacci Sequence",
      "3.1 Recursive Fibonacci Sequence"
    ]
  },
  {
    "objectID": "3 - fib.html#benchmarks",
    "href": "3 - fib.html#benchmarks",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "Benchmarks",
    "text": "Benchmarks\n\nbench::mark(\n  C = fib_c(40),\n  Cpp = fib_cpp(40),\n  Julia = fib_jl(41L),\n  Rust = fib_rs(40),\n  FORTRAN = fib_fortran(40),\n  R = fib_r(40),\n  Python = fib_py(40),\n  check = F\n)\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C             2.7µs      3µs   250950.   19.23KB     0   \n2 Cpp           1.5µs    2.2µs   184602.    7.88KB    18.5 \n3 Julia        10.4µs   20.3µs    29088.    5.94KB     0   \n4 Rust         67.8µs   73.1µs    10937.    5.02KB     0   \n5 FORTRAN       2.7µs      3µs   271812.   17.73KB     0   \n6 R             7.4µs    8.4µs    91006.      592B     9.10\n7 Python       52.4µs   57.2µs    13366.     5.2KB     4.15",
    "crumbs": [
      "Home",
      "Recursive Fibonacci Sequence",
      "3.1 Recursive Fibonacci Sequence"
    ]
  },
  {
    "objectID": "5 - convolution.html",
    "href": "5 - convolution.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "I have 2 types of data here, one being used as an example if they are actually equal or the function is working. While the other one is used for benchmarking.\n\n# To elaborate an example\nset.seed(120)\nx &lt;- rnorm(10, mean = 10, sd = 2)\ny &lt;- rexp(10, rate = 1.5)\n\n# For Benchmarking\nset.seed(120)\nxx &lt;- rnorm(5e3, mean = 10, sd = 2)\nyy &lt;- rexp(5e3, rate = 1.5)\n\n\nCC++JuliaRustFORTRANRPython\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid convolve_c(double *x, double *y, int *n, int *m, double *result) {\n    int result_size = *n + *m - 1;\n\n    for (int i = 0; i &lt; result_size; i++) {\n        int j_min = (i &gt;= *m - 1) ? i - (*m - 1) : 0;\n        int j_max = (i &lt; *n - 1) ? i : *n - 1;\n\n        result[i] = 0;\n        for (int j = j_min; j &lt;= j_max; j++) {\n            result[i] += x[j] * y[i - j];\n        }\n    }\n}\n\n\nconvolve_c &lt;- function(x, y) {\n    totalSize &lt;- length(x) + length(y) - 1\n    result &lt;- double(totalSize)  # Initialize result vector\n    result &lt;- .C(\"convolve_c\", \n                 as.double(x), as.double(y), \n                 as.integer(length(x)), as.integer(length(y)),\n                 result=double(totalSize))$result\n    return(result)\n}\n\nconvolve_c(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector convolve_cpp(NumericVector x, NumericVector y) {\n    int n = x.size();\n    int m = y.size();\n    int result_size = n + m - 1;\n    NumericVector result(result_size);\n\n    for (int i = 0; i &lt; result_size; i++) {\n        int j_min = (i &gt;= m - 1) ? i - (m - 1) : 0;\n        int j_max = (i &lt; n - 1) ? i : n - 1;\n        double sum = 0.0;\n        // Unroll the inner loop for better performance\n        for (int j = j_min; j &lt;= j_max - 4; j += 4) {\n            sum += x[j] * y[i - j] +\n                   x[j + 1] * y[i - (j + 1)] +\n                   x[j + 2] * y[i - (j + 2)] +\n                   x[j + 3] * y[i - (j + 3)];\n        }\n        // Handle remaining elements if any\n        for (int j = j_max - (j_max - j_min) % 4; j &lt;= j_max; j++) {\n            sum += x[j] * y[i - j];\n        }\n        result[i] = sum;\n    }\n\n    return result;\n}\n\n\nconvolve_cpp(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nfunction convolve_vector(x::Vector{Float64}, y::Vector{Float64})\n    n = length(x)\n    m = length(y)\n    result = zeros(Float64, n + m - 1)\n    paddedX = zeros(Float64, n + m - 1)\n    paddedY = zeros(Float64, n + m - 1)\n\n    paddedX[1:n] = x\n    paddedY[1:m] = y\n\n    for i in 1:(n + m - 1)\n        for j in 1:i\n            result[i] += paddedX[j] * paddedY[i - j + 1]\n        end\n    end\n\n    return result\nend\n\nconvolve_vector (generic function with 1 method)\n\n\n\nconvolve_jl &lt;- JuliaCall::julia_eval(\"convolve_vector\")\nconvolve_jl(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn convolve_rs(x: Vec&lt;f64&gt;, y: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; {\n    let n = x.len();\n    let m = y.len();\n    let result_size = n + m - 1;\n    let mut result = vec![0.0; result_size];\n\n    for i in 0..result_size {\n        let j_min = if i &gt;= m - 1 { i - (m - 1) } else { 0 };\n        let j_max = if i &lt; n - 1 { i } else { n - 1 };\n        for j in j_min..=j_max {\n            result[i] += x[j] * y[i - j];\n        }\n    }\n\n    result\n}\n\n\nconvolve_rs(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nsubroutine convolve_fortran(x, n, y, m, result)\n    implicit none\n    integer, intent(in) :: n, m\n    real(8), intent(in) :: x(n), y(m)\n    real(8), intent(out) :: result(n + m - 1)\n    real(8) :: paddedX(n + m - 1), paddedY(n + m - 1)\n    integer :: i, j\n\n    ! Initialize paddedX and paddedY with zeros\n    paddedX = 0.0d0\n    paddedY = 0.0d0\n\n    ! Copy elements of x and y to paddedX and paddedY, respectively\n    paddedX(1:n) = x\n    paddedY(1:m) = y\n\n    ! Compute convolution\n    do i = 1, n + m - 1\n        do j = 1, i\n            result(i) = result(i) + paddedX(j) * paddedY(i - j + 1)\n        end do\n    end do\nend subroutine convolve_fortran\n\n\nconvolve_fortran &lt;- function(x, y) {\n  totalSize &lt;- length(x) + length(y) - 1\n  result &lt;- .Fortran(\"convolve_fortran\", \n                     as.double(x), as.integer(length(x)), \n                     as.double(y), as.integer(length(y)),\n                     result=double(totalSize))$result\n  return(result)\n}\n\nconvolve_fortran(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nconvolve_r &lt;- function(x, y) {\n    n &lt;- length(x)\n    m &lt;- length(y)\n    result &lt;- rep(0, n + m - 1)\n    paddedX &lt;- rep(0, n + m - 1)\n    paddedY &lt;- rep(0, n + m - 1)\n    \n    paddedX[1:n] &lt;- x\n    paddedY[1:m] &lt;- y\n    \n    for (i in 1:(n + m - 1)) {\n        for (j in 1:i) {\n            result[i] &lt;- result[i] + paddedX[j] * paddedY[i - j + 1]\n        }\n    }\n    \n    return(result)\n}\n\nconvolve_r(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nimport numpy as np\n\ndef convolve_py(x, y):\n    n = len(x)\n    m = len(y)\n    result = np.zeros(n + m - 1)\n    paddedX = np.zeros(n + m - 1)\n    paddedY = np.zeros(n + m - 1)\n    \n    paddedX[:n] = x\n    paddedY[:m] = y\n    \n    for i in range(1, n + m):\n        for j in range(1, i+1):\n            result[i-1] += paddedX[j-1] * paddedY[i-j]\n    \n    return result\n\n\nconvolve_py &lt;- reticulate::py$convolve_py\nconvolve_py(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219",
    "crumbs": [
      "Home",
      "Convolution",
      "5.1 Convolution"
    ]
  },
  {
    "objectID": "5 - convolution.html#convolution",
    "href": "5 - convolution.html#convolution",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "I have 2 types of data here, one being used as an example if they are actually equal or the function is working. While the other one is used for benchmarking.\n\n# To elaborate an example\nset.seed(120)\nx &lt;- rnorm(10, mean = 10, sd = 2)\ny &lt;- rexp(10, rate = 1.5)\n\n# For Benchmarking\nset.seed(120)\nxx &lt;- rnorm(5e3, mean = 10, sd = 2)\nyy &lt;- rexp(5e3, rate = 1.5)\n\n\nCC++JuliaRustFORTRANRPython\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid convolve_c(double *x, double *y, int *n, int *m, double *result) {\n    int result_size = *n + *m - 1;\n\n    for (int i = 0; i &lt; result_size; i++) {\n        int j_min = (i &gt;= *m - 1) ? i - (*m - 1) : 0;\n        int j_max = (i &lt; *n - 1) ? i : *n - 1;\n\n        result[i] = 0;\n        for (int j = j_min; j &lt;= j_max; j++) {\n            result[i] += x[j] * y[i - j];\n        }\n    }\n}\n\n\nconvolve_c &lt;- function(x, y) {\n    totalSize &lt;- length(x) + length(y) - 1\n    result &lt;- double(totalSize)  # Initialize result vector\n    result &lt;- .C(\"convolve_c\", \n                 as.double(x), as.double(y), \n                 as.integer(length(x)), as.integer(length(y)),\n                 result=double(totalSize))$result\n    return(result)\n}\n\nconvolve_c(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector convolve_cpp(NumericVector x, NumericVector y) {\n    int n = x.size();\n    int m = y.size();\n    int result_size = n + m - 1;\n    NumericVector result(result_size);\n\n    for (int i = 0; i &lt; result_size; i++) {\n        int j_min = (i &gt;= m - 1) ? i - (m - 1) : 0;\n        int j_max = (i &lt; n - 1) ? i : n - 1;\n        double sum = 0.0;\n        // Unroll the inner loop for better performance\n        for (int j = j_min; j &lt;= j_max - 4; j += 4) {\n            sum += x[j] * y[i - j] +\n                   x[j + 1] * y[i - (j + 1)] +\n                   x[j + 2] * y[i - (j + 2)] +\n                   x[j + 3] * y[i - (j + 3)];\n        }\n        // Handle remaining elements if any\n        for (int j = j_max - (j_max - j_min) % 4; j &lt;= j_max; j++) {\n            sum += x[j] * y[i - j];\n        }\n        result[i] = sum;\n    }\n\n    return result;\n}\n\n\nconvolve_cpp(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nfunction convolve_vector(x::Vector{Float64}, y::Vector{Float64})\n    n = length(x)\n    m = length(y)\n    result = zeros(Float64, n + m - 1)\n    paddedX = zeros(Float64, n + m - 1)\n    paddedY = zeros(Float64, n + m - 1)\n\n    paddedX[1:n] = x\n    paddedY[1:m] = y\n\n    for i in 1:(n + m - 1)\n        for j in 1:i\n            result[i] += paddedX[j] * paddedY[i - j + 1]\n        end\n    end\n\n    return result\nend\n\nconvolve_vector (generic function with 1 method)\n\n\n\nconvolve_jl &lt;- JuliaCall::julia_eval(\"convolve_vector\")\nconvolve_jl(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn convolve_rs(x: Vec&lt;f64&gt;, y: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; {\n    let n = x.len();\n    let m = y.len();\n    let result_size = n + m - 1;\n    let mut result = vec![0.0; result_size];\n\n    for i in 0..result_size {\n        let j_min = if i &gt;= m - 1 { i - (m - 1) } else { 0 };\n        let j_max = if i &lt; n - 1 { i } else { n - 1 };\n        for j in j_min..=j_max {\n            result[i] += x[j] * y[i - j];\n        }\n    }\n\n    result\n}\n\n\nconvolve_rs(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nsubroutine convolve_fortran(x, n, y, m, result)\n    implicit none\n    integer, intent(in) :: n, m\n    real(8), intent(in) :: x(n), y(m)\n    real(8), intent(out) :: result(n + m - 1)\n    real(8) :: paddedX(n + m - 1), paddedY(n + m - 1)\n    integer :: i, j\n\n    ! Initialize paddedX and paddedY with zeros\n    paddedX = 0.0d0\n    paddedY = 0.0d0\n\n    ! Copy elements of x and y to paddedX and paddedY, respectively\n    paddedX(1:n) = x\n    paddedY(1:m) = y\n\n    ! Compute convolution\n    do i = 1, n + m - 1\n        do j = 1, i\n            result(i) = result(i) + paddedX(j) * paddedY(i - j + 1)\n        end do\n    end do\nend subroutine convolve_fortran\n\n\nconvolve_fortran &lt;- function(x, y) {\n  totalSize &lt;- length(x) + length(y) - 1\n  result &lt;- .Fortran(\"convolve_fortran\", \n                     as.double(x), as.integer(length(x)), \n                     as.double(y), as.integer(length(y)),\n                     result=double(totalSize))$result\n  return(result)\n}\n\nconvolve_fortran(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nconvolve_r &lt;- function(x, y) {\n    n &lt;- length(x)\n    m &lt;- length(y)\n    result &lt;- rep(0, n + m - 1)\n    paddedX &lt;- rep(0, n + m - 1)\n    paddedY &lt;- rep(0, n + m - 1)\n    \n    paddedX[1:n] &lt;- x\n    paddedY[1:m] &lt;- y\n    \n    for (i in 1:(n + m - 1)) {\n        for (j in 1:i) {\n            result[i] &lt;- result[i] + paddedX[j] * paddedY[i - j + 1]\n        }\n    }\n    \n    return(result)\n}\n\nconvolve_r(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219\n\n\n\n\n\nimport numpy as np\n\ndef convolve_py(x, y):\n    n = len(x)\n    m = len(y)\n    result = np.zeros(n + m - 1)\n    paddedX = np.zeros(n + m - 1)\n    paddedY = np.zeros(n + m - 1)\n    \n    paddedX[:n] = x\n    paddedY[:m] = y\n    \n    for i in range(1, n + m):\n        for j in range(1, i+1):\n            result[i-1] += paddedX[j-1] * paddedY[i-j]\n    \n    return result\n\n\nconvolve_py &lt;- reticulate::py$convolve_py\nconvolve_py(x, y) |&gt; head(10)\n\n [1]  1.866342 10.531917 12.357334 14.054101 34.520841 39.345087 41.662725\n [8] 55.926328 68.759844 65.767219",
    "crumbs": [
      "Home",
      "Convolution",
      "5.1 Convolution"
    ]
  },
  {
    "objectID": "5 - convolution.html#benchmark",
    "href": "5 - convolution.html#benchmark",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "Benchmark",
    "text": "Benchmark\n\nbench::mark(\n     C = convolve_c(xx, yy),\n     `C++` = convolve_cpp(xx, yy),\n     Julia = convolve_jl(xx, yy),\n     Rust = convolve_rs(xx, yy),\n     FORTRAN = convolve_fortran(xx, yy),\n     R = convolve_r(xx, yy),\n     Python = convolve_py(xx, yy),\n     check = F\n)\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C           43.39ms  48.55ms   19.3      356.2KB        0\n2 C++         13.68ms  21.58ms   39.9       85.8KB        0\n3 Julia       88.96ms 106.91ms    9.49      83.9KB        0\n4 Rust          2.55s    2.55s    0.392       83KB        0\n5 FORTRAN     90.28ms  103.5ms    9.02       274KB        0\n6 R            16.08s   16.08s    0.0622   273.6KB        0\n7 Python        1.05m    1.05m    0.0159   206.2KB        0",
    "crumbs": [
      "Home",
      "Convolution",
      "5.1 Convolution"
    ]
  }
]