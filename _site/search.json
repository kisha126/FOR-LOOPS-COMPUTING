[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "In this activity, I show you the programming languages that can be used in computing with the use of for loops.\nNote that not all the programming languages are listed in this example because these are all the programming languages I know that can be exported into R."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "In this activity, I show you the programming languages that can be used in computing with the use of for loops.\nNote that not all the programming languages are listed in this example because these are all the programming languages I know that can be exported into R."
  },
  {
    "objectID": "3 - fib.html",
    "href": "3 - fib.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "Same procedure as approximating the \\(\\pi\\), compile and then compile\n\nCC++JuliaRustFORTRANRPython\n\n\n\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt;\n\nvoid fib_c(int *n, int *seq) {\n    seq[0] = 0;\n    if (*n &gt; 0) {\n        seq[1] = 1;\n        for (int i = 2; i &lt;= *n; ++i) {\n            seq[i] = seq[i - 1] + seq[i - 2];\n        }\n    }\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c94c5f751229.c -o c94c5f751229.o\ngcc -shared -s -static-libgcc -o c94c5f751229.dll tmp.def c94c5f751229.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_c &lt;- function(n) {\n  seq &lt;- integer(n + 1)\n  .C(\"fib_c\", n = as.integer(n), seq = as.integer(seq))$seq\n}\nfib_c(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector fib_cpp(int n){\n  IntegerVector fibSequence(n + 1);\n  fibSequence[0] = 0;\n  if (n &gt; 1) {\n    fibSequence[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n  }\n  return fibSequence;\n  \n}\n\n\n/***R\nfib_cpp(10)\n*/\n\n\n\n\nfunction fib_jl(n::Int)\n  fib = Int[]\n  push!(fib, 0)  \n  push!(fib, 1)  \n  \n  \n  for i in 3:n\n      push!(fib, fib[i - 1] + fib[i - 2])  \n  end\n  \n  return fib\nend\n\nfib_jl (generic function with 1 method)\n\n\n\nfib_jl &lt;- JuliaCall::julia_eval(\"fib_jl\")\nfib_jl(10L)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\n\n\n\nuse extendr_api::prelude::*;\nuse std::collections::HashMap;\n\nfn fibonacci(n: i32, memo: &mut HashMap&lt;i32, i32&gt;) -&gt; i32 {\n    if let Some(&result) = memo.get(&n) {\n        return result;\n    }\n\n    let result = if n &lt;= 1 {\n        n\n    } else {\n        fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    };\n\n    memo.insert(n, result);\n    result\n}\n\n#[extendr]\nfn fib_rs(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut sequence = vec![];\n    let mut memo = HashMap::new();\n\n    for i in 0..n + 1 {\n        sequence.push(fibonacci(i, &mut memo));\n    }\n\n    sequence\n}\n\n\nfib_rs(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nsubroutine fib_f(n, fib)\n    integer, intent(in) :: n\n    integer, intent(out) :: fib(n)\n    integer :: i\n    \n    fib(1) = 0\n    fib(2) = 1\n\n    do i = 3, n + 1\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\nend subroutine fib_f\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f9594c39251724.f95 -o f9594c39251724.o\ngcc -shared -s -static-libgcc -o f9594c39251724.dll tmp.def f9594c39251724.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_fortran &lt;- function(n) {\n  n &lt;- n + 1\n  .Fortran(\"fib_f\", as.integer(n), fib = integer(n))$fib\n}\nfib_fortran(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nfib_r &lt;- function(n) {\n  fib &lt;- integer(n + 1)\n  fib[1] &lt;- 0\n  fib[2] &lt;- 1\n  for (i in 3:(n+1)) {\n    fib[i] &lt;- fib[i - 1] + fib[i - 2]\n  }\n  return(fib)\n}\n\nfib_r(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\ndef fib_p(n):\n    n = int(n)\n    fib_seq = [0, 1]\n    for i in range(2, n + 1):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\n\nfib_py &lt;- reticulate::py$fib_p\nfib_py(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55",
    "crumbs": [
      "Home",
      "Recursive Fibonacci Sequence",
      "Recursive Fibonacci Sequence"
    ]
  },
  {
    "objectID": "3 - fib.html#recursive-fibonacci-sequence",
    "href": "3 - fib.html#recursive-fibonacci-sequence",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "Same procedure as approximating the \\(\\pi\\), compile and then compile\n\nCC++JuliaRustFORTRANRPython\n\n\n\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt;\n\nvoid fib_c(int *n, int *seq) {\n    seq[0] = 0;\n    if (*n &gt; 0) {\n        seq[1] = 1;\n        for (int i = 2; i &lt;= *n; ++i) {\n            seq[i] = seq[i - 1] + seq[i - 2];\n        }\n    }\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c94c5f751229.c -o c94c5f751229.o\ngcc -shared -s -static-libgcc -o c94c5f751229.dll tmp.def c94c5f751229.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_c &lt;- function(n) {\n  seq &lt;- integer(n + 1)\n  .C(\"fib_c\", n = as.integer(n), seq = as.integer(seq))$seq\n}\nfib_c(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector fib_cpp(int n){\n  IntegerVector fibSequence(n + 1);\n  fibSequence[0] = 0;\n  if (n &gt; 1) {\n    fibSequence[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n  }\n  return fibSequence;\n  \n}\n\n\n/***R\nfib_cpp(10)\n*/\n\n\n\n\nfunction fib_jl(n::Int)\n  fib = Int[]\n  push!(fib, 0)  \n  push!(fib, 1)  \n  \n  \n  for i in 3:n\n      push!(fib, fib[i - 1] + fib[i - 2])  \n  end\n  \n  return fib\nend\n\nfib_jl (generic function with 1 method)\n\n\n\nfib_jl &lt;- JuliaCall::julia_eval(\"fib_jl\")\nfib_jl(10L)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\n\n\n\nuse extendr_api::prelude::*;\nuse std::collections::HashMap;\n\nfn fibonacci(n: i32, memo: &mut HashMap&lt;i32, i32&gt;) -&gt; i32 {\n    if let Some(&result) = memo.get(&n) {\n        return result;\n    }\n\n    let result = if n &lt;= 1 {\n        n\n    } else {\n        fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    };\n\n    memo.insert(n, result);\n    result\n}\n\n#[extendr]\nfn fib_rs(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut sequence = vec![];\n    let mut memo = HashMap::new();\n\n    for i in 0..n + 1 {\n        sequence.push(fibonacci(i, &mut memo));\n    }\n\n    sequence\n}\n\n\nfib_rs(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nsubroutine fib_f(n, fib)\n    integer, intent(in) :: n\n    integer, intent(out) :: fib(n)\n    integer :: i\n    \n    fib(1) = 0\n    fib(2) = 1\n\n    do i = 3, n + 1\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\nend subroutine fib_f\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f9594c39251724.f95 -o f9594c39251724.o\ngcc -shared -s -static-libgcc -o f9594c39251724.dll tmp.def f9594c39251724.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_fortran &lt;- function(n) {\n  n &lt;- n + 1\n  .Fortran(\"fib_f\", as.integer(n), fib = integer(n))$fib\n}\nfib_fortran(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nfib_r &lt;- function(n) {\n  fib &lt;- integer(n + 1)\n  fib[1] &lt;- 0\n  fib[2] &lt;- 1\n  for (i in 3:(n+1)) {\n    fib[i] &lt;- fib[i - 1] + fib[i - 2]\n  }\n  return(fib)\n}\n\nfib_r(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\ndef fib_p(n):\n    n = int(n)\n    fib_seq = [0, 1]\n    for i in range(2, n + 1):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\n\nfib_py &lt;- reticulate::py$fib_p\nfib_py(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55",
    "crumbs": [
      "Home",
      "Recursive Fibonacci Sequence",
      "Recursive Fibonacci Sequence"
    ]
  },
  {
    "objectID": "3 - fib.html#benchmarks",
    "href": "3 - fib.html#benchmarks",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "Benchmarks",
    "text": "Benchmarks\n\nbench::mark(\n  C = fib_c(40),\n  Cpp = fib_cpp(40),\n  Julia = fib_jl(41L),\n  Rust = fib_rs(40),\n  FORTRAN = fib_fortran(40),\n  R = fib_r(40),\n  Python = fib_py(40),\n  check = F\n)\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C             2.7µs      3µs   249137.   19.23KB    24.9 \n2 Cpp           1.6µs    1.8µs   272396.    7.88KB     0   \n3 Julia         9.8µs   10.4µs    76471.    5.94KB     0   \n4 Rust         68.4µs   69.9µs    13155.    5.02KB     0   \n5 FORTRAN       2.9µs    3.2µs   231509.   17.73KB     0   \n6 R             7.4µs    8.2µs   107845.      592B    10.8 \n7 Python       55.4µs   59.4µs    13206.     5.2KB     4.14",
    "crumbs": [
      "Home",
      "Recursive Fibonacci Sequence",
      "Recursive Fibonacci Sequence"
    ]
  },
  {
    "objectID": "1 - intro.html",
    "href": "1 - intro.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "Here are the list of languages will be used in this activity:\n\nC\n\nC is maybe the easiest compiled language to learn. It is so easy to compile a C code into R.\n\nC++\n\nDespite its reputation for complexity, leveraging tools like Rcpp and its APIs makes writing C++ code more accessible. Plus, exporting C++ code into the R environment is a breeze, even I, who sometimes write a bad code, can write a C++ code and it is so easy to export a C++ code into R environment.\nCompared to C, compilation in C++ might take a bit longer due to various factors.\nwith the Rcpp namespace, you can seamlessly integrate C++ features like NumericVector and DataFrame, mirroring R’s class system.\n\nJulia\n\nJulia shares similarities with C in that it’s a compiled language, effectively addressing the “2 language problem” by eliminating the need for separate languages like C, C++, or FORTRAN APIs.\nJulia is a JIT compiled and it is able to be both fast and easy to read.\n\nRust\n\nRust, akin to C/C++, prioritizes memory safety.\nPreparing to compile Rust code in R involves installing necessary Build Tools and rustc cargo via the terminal.\n\nFORTRAN\n\nDespite its age, FORTRAN remains indispensable in the realm of computing, boasting speed comparable to C/C++.\nIt’s still widely used as source code for R packages, fAsianOptions as its example.\n\nR\n\nWhile maybe R isn’t exclusively utilized for computing, it’s a statistical computing language widely embraced in statistical analysis.\nWith R, it is so easy to conduct a pure data science like data manipulation and visulizations, thanks to the libraries, such as dplyr and ggplot2, and to integrate “structured” databases with DBI and dbplyr.\n\nPython\n\nPython is an effective general purpose language that can be even used in statistics or any fields of computing.\n\n\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. I only used those languages that can be both used in computing and listed in knitr. Also, I wrapped the codes from other languages so that it would be easy for me to benchmark them with bench::time.",
    "crumbs": [
      "Home",
      "Introduction",
      "Languages"
    ]
  },
  {
    "objectID": "1 - intro.html#languages",
    "href": "1 - intro.html#languages",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "Here are the list of languages will be used in this activity:\n\nC\n\nC is maybe the easiest compiled language to learn. It is so easy to compile a C code into R.\n\nC++\n\nDespite its reputation for complexity, leveraging tools like Rcpp and its APIs makes writing C++ code more accessible. Plus, exporting C++ code into the R environment is a breeze, even I, who sometimes write a bad code, can write a C++ code and it is so easy to export a C++ code into R environment.\nCompared to C, compilation in C++ might take a bit longer due to various factors.\nwith the Rcpp namespace, you can seamlessly integrate C++ features like NumericVector and DataFrame, mirroring R’s class system.\n\nJulia\n\nJulia shares similarities with C in that it’s a compiled language, effectively addressing the “2 language problem” by eliminating the need for separate languages like C, C++, or FORTRAN APIs.\nJulia is a JIT compiled and it is able to be both fast and easy to read.\n\nRust\n\nRust, akin to C/C++, prioritizes memory safety.\nPreparing to compile Rust code in R involves installing necessary Build Tools and rustc cargo via the terminal.\n\nFORTRAN\n\nDespite its age, FORTRAN remains indispensable in the realm of computing, boasting speed comparable to C/C++.\nIt’s still widely used as source code for R packages, fAsianOptions as its example.\n\nR\n\nWhile maybe R isn’t exclusively utilized for computing, it’s a statistical computing language widely embraced in statistical analysis.\nWith R, it is so easy to conduct a pure data science like data manipulation and visulizations, thanks to the libraries, such as dplyr and ggplot2, and to integrate “structured” databases with DBI and dbplyr.\n\nPython\n\nPython is an effective general purpose language that can be even used in statistics or any fields of computing.\n\n\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. I only used those languages that can be both used in computing and listed in knitr. Also, I wrapped the codes from other languages so that it would be easy for me to benchmark them with bench::time.",
    "crumbs": [
      "Home",
      "Introduction",
      "Languages"
    ]
  },
  {
    "objectID": "2 - pi_approx.html",
    "href": "2 - pi_approx.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "It took hundreds of years to precisely approximate the \\(\\pi\\).\nI used the Leibniz formula to approximate \\(\\pi\\). It came from an alternating series, a power series of \\(\\frac{1}{x^2+1}\\).\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 0}^{\\infty} {\\frac{(-1)^k}{2k + 1}}\n\\]\nWe need to adjust a little bit for the programming languages that starts with index-1, like R, Julia and FORTRAN.\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 1}^{\\infty} {\\frac{(-1)^k}{2k - 1}}\n\\]\n\nCC++JuliaRustFORTRANRPython\n\n\nIf your purpose is a language for fast computation within R, C is maybe easier than C++ but in order this to be working and exportable, the inputs and outputs of the computation were stored in the memory address, a.k.a. the pointers.\n\n#include &lt;stdio.h&gt;\n\nvoid pi_approx_c(int *n, double *result) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; *n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  *result = 4 * pi_4;\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c1aac72cf4cdd.c -o c1aac72cf4cdd.o\ngcc -shared -s -static-libgcc -o c1aac72cf4cdd.dll tmp.def c1aac72cf4cdd.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nIn order to wrap the C code into R, use .C and then extract the result via $res.\n\npi_approx_c &lt;- function(n) {\n  res &lt;- .C(\"pi_approx_c\", as.integer(n), res=numeric(1))$res\n  return(res)\n}\n\npi_approx_c(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, the C++ code is way similar to the C code except, we don’t need to use pointers in order share the results in a memory address, instead we only write the C++ code in a standard way. Like I said, using Rcpp, the C++ code is so easy to be exported, as long as we made it to be error-free.\nAfter compiling, the pi_approx_cpp function will be exported by // [[Rcpp::export]] attributes and saved into R Global Environment directly.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble pi_approx_cpp(int n) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  return 4 * pi_4;\n}\n\n/***R\npi_approx_cpp(1e5)\n*/\n\n\n\nAs you can see, we only write few codes, unlike in C/C++, to approximate the \\(\\pi\\)\n\nfunction pi_approx_jl(n)\n    pi_4 = 0.0\n    sign = 1.0\n    for i in 1:n\n        pi_4 += sign / (2*i - 1)\n        sign *= -1\n    end\n    return 4 * pi_4\nend\n\npi_approx_jl (generic function with 1 method)\n\n\nWith JuliaCall, you can wrap the Julia function into R via julia_eval. But there are few other ways to call it, but I found julia_eval more convenient.\n(Note: If you are already familiar with reticulate, this is the same as py_eval)\n\npi_approx_jl &lt;- JuliaCall::julia_eval(\"pi_approx_jl\")\npi_approx_jl(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, we use the extendr and #[extendr] attribute API to write a Rust code and compile it into R, just like we did with Rcpp to compile the C++ code into R\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn pi_approx_rs(n: i32) -&gt; f64 {\n    let mut pi_4 = 0.0;\n    let mut sign = 1.0;\n\n    for i in 0..n {\n        pi_4 += sign / (2 * i + 1) as f64;\n        sign *= -1.0;\n    }\n\n    4.0 * pi_4\n}\n\nAfter compiling, just like C++, the pi_approx_rs function in Rust will be wrapped and saved into R Global Environment directly.\n\npi_approx_rs(1e5)\n\n[1] 3.141583\n\n\n\n\nMaybe FORTRAN is fast, but the solution is more boilerplate, although for me it is more readable compared to C/C++. Just like C, we need the result to be store in memory address.\nIf you use old FORTRAN version, you might need to CAPITALIZE the FORTRAN program. But we use the ’95 version of FORTRAN so we don’t need to CAPITALIZE the program.\n\nsubroutine pi_approx(n, result)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: result\n    integer :: i\n    real(8) :: pi_4, sign\n    \n    pi_4 = 0.0\n    sign = 1.0\n    \n    do i = 1, n\n        pi_4 = pi_4 + sign / (2 * i - 1)\n        sign = sign * (-1.0)\n    end do\n    \n    result = 4 * pi_4\nend subroutine pi_approx\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f951aac6d57265.f95 -o f951aac6d57265.o\ngcc -shared -s -static-libgcc -o f951aac6d57265.dll tmp.def f951aac6d57265.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nJust like C, but instead, in order to natively call the FORTRAN code into R, use .Fortran and then extract the result via $result.\n\npi_approx_fortran &lt;- function(n) {\n  result &lt;- .Fortran(\"pi_approx\", as.integer(n), result=double(1))$result\n  return(result)\n}\n\npi_approx_fortran(1e5)\n\n[1] 3.141583\n\n\n\n\nR is so close to be functional programming and to be Domain Specific Language (or DSL). It is so functional, you need to use &lt;- function() to define a function and I sometimes agree that this is ugly but hey it works! This is just my opinion.\nR is already a default language in RStudio, so the function we define is already callable in R Global Environment.\n\npi_approx_r &lt;- function(n) {\n  pi_4 &lt;- 0\n  sign &lt;- 1\n  \n  for (i in 1:n) {\n    pi_4 &lt;- pi_4 + sign / (2*i - 1)\n    sign &lt;- sign * -1\n  }\n  \n  return(4 * pi_4)\n}\n\npi_approx_r(1e5)\n\n[1] 3.141583\n\n\n\n\nR and Python has so much similarities, except Python is more onto general purpose language.\n\ndef pi_approx_py(n):\n    n = int(n)\n    pi_4 = 0\n    sign = 1\n    \n    for i in range(n):\n        pi_4 += sign / (2 * i + 1)\n        sign *= -1\n    return pi_4 * 4\n\nThe defined function in Python is also callable. Using py module in reticulate package, you can easily interact with any Python objects in Python module.\n\npi_approx_py &lt;- reticulate::py$pi_approx_py\npi_approx_py(1e5)\n\n[1] 3.141583",
    "crumbs": [
      "Home",
      "Approximating Pi",
      "Approximating $\\pi$"
    ]
  },
  {
    "objectID": "2 - pi_approx.html#approximating-pi",
    "href": "2 - pi_approx.html#approximating-pi",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "It took hundreds of years to precisely approximate the \\(\\pi\\).\nI used the Leibniz formula to approximate \\(\\pi\\). It came from an alternating series, a power series of \\(\\frac{1}{x^2+1}\\).\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 0}^{\\infty} {\\frac{(-1)^k}{2k + 1}}\n\\]\nWe need to adjust a little bit for the programming languages that starts with index-1, like R, Julia and FORTRAN.\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 1}^{\\infty} {\\frac{(-1)^k}{2k - 1}}\n\\]\n\nCC++JuliaRustFORTRANRPython\n\n\nIf your purpose is a language for fast computation within R, C is maybe easier than C++ but in order this to be working and exportable, the inputs and outputs of the computation were stored in the memory address, a.k.a. the pointers.\n\n#include &lt;stdio.h&gt;\n\nvoid pi_approx_c(int *n, double *result) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; *n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  *result = 4 * pi_4;\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c1aac72cf4cdd.c -o c1aac72cf4cdd.o\ngcc -shared -s -static-libgcc -o c1aac72cf4cdd.dll tmp.def c1aac72cf4cdd.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nIn order to wrap the C code into R, use .C and then extract the result via $res.\n\npi_approx_c &lt;- function(n) {\n  res &lt;- .C(\"pi_approx_c\", as.integer(n), res=numeric(1))$res\n  return(res)\n}\n\npi_approx_c(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, the C++ code is way similar to the C code except, we don’t need to use pointers in order share the results in a memory address, instead we only write the C++ code in a standard way. Like I said, using Rcpp, the C++ code is so easy to be exported, as long as we made it to be error-free.\nAfter compiling, the pi_approx_cpp function will be exported by // [[Rcpp::export]] attributes and saved into R Global Environment directly.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble pi_approx_cpp(int n) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  return 4 * pi_4;\n}\n\n/***R\npi_approx_cpp(1e5)\n*/\n\n\n\nAs you can see, we only write few codes, unlike in C/C++, to approximate the \\(\\pi\\)\n\nfunction pi_approx_jl(n)\n    pi_4 = 0.0\n    sign = 1.0\n    for i in 1:n\n        pi_4 += sign / (2*i - 1)\n        sign *= -1\n    end\n    return 4 * pi_4\nend\n\npi_approx_jl (generic function with 1 method)\n\n\nWith JuliaCall, you can wrap the Julia function into R via julia_eval. But there are few other ways to call it, but I found julia_eval more convenient.\n(Note: If you are already familiar with reticulate, this is the same as py_eval)\n\npi_approx_jl &lt;- JuliaCall::julia_eval(\"pi_approx_jl\")\npi_approx_jl(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, we use the extendr and #[extendr] attribute API to write a Rust code and compile it into R, just like we did with Rcpp to compile the C++ code into R\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn pi_approx_rs(n: i32) -&gt; f64 {\n    let mut pi_4 = 0.0;\n    let mut sign = 1.0;\n\n    for i in 0..n {\n        pi_4 += sign / (2 * i + 1) as f64;\n        sign *= -1.0;\n    }\n\n    4.0 * pi_4\n}\n\nAfter compiling, just like C++, the pi_approx_rs function in Rust will be wrapped and saved into R Global Environment directly.\n\npi_approx_rs(1e5)\n\n[1] 3.141583\n\n\n\n\nMaybe FORTRAN is fast, but the solution is more boilerplate, although for me it is more readable compared to C/C++. Just like C, we need the result to be store in memory address.\nIf you use old FORTRAN version, you might need to CAPITALIZE the FORTRAN program. But we use the ’95 version of FORTRAN so we don’t need to CAPITALIZE the program.\n\nsubroutine pi_approx(n, result)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: result\n    integer :: i\n    real(8) :: pi_4, sign\n    \n    pi_4 = 0.0\n    sign = 1.0\n    \n    do i = 1, n\n        pi_4 = pi_4 + sign / (2 * i - 1)\n        sign = sign * (-1.0)\n    end do\n    \n    result = 4 * pi_4\nend subroutine pi_approx\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f951aac6d57265.f95 -o f951aac6d57265.o\ngcc -shared -s -static-libgcc -o f951aac6d57265.dll tmp.def f951aac6d57265.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nJust like C, but instead, in order to natively call the FORTRAN code into R, use .Fortran and then extract the result via $result.\n\npi_approx_fortran &lt;- function(n) {\n  result &lt;- .Fortran(\"pi_approx\", as.integer(n), result=double(1))$result\n  return(result)\n}\n\npi_approx_fortran(1e5)\n\n[1] 3.141583\n\n\n\n\nR is so close to be functional programming and to be Domain Specific Language (or DSL). It is so functional, you need to use &lt;- function() to define a function and I sometimes agree that this is ugly but hey it works! This is just my opinion.\nR is already a default language in RStudio, so the function we define is already callable in R Global Environment.\n\npi_approx_r &lt;- function(n) {\n  pi_4 &lt;- 0\n  sign &lt;- 1\n  \n  for (i in 1:n) {\n    pi_4 &lt;- pi_4 + sign / (2*i - 1)\n    sign &lt;- sign * -1\n  }\n  \n  return(4 * pi_4)\n}\n\npi_approx_r(1e5)\n\n[1] 3.141583\n\n\n\n\nR and Python has so much similarities, except Python is more onto general purpose language.\n\ndef pi_approx_py(n):\n    n = int(n)\n    pi_4 = 0\n    sign = 1\n    \n    for i in range(n):\n        pi_4 += sign / (2 * i + 1)\n        sign *= -1\n    return pi_4 * 4\n\nThe defined function in Python is also callable. Using py module in reticulate package, you can easily interact with any Python objects in Python module.\n\npi_approx_py &lt;- reticulate::py$pi_approx_py\npi_approx_py(1e5)\n\n[1] 3.141583",
    "crumbs": [
      "Home",
      "Approximating Pi",
      "Approximating $\\pi$"
    ]
  },
  {
    "objectID": "2 - pi_approx.html#benchmarks",
    "href": "2 - pi_approx.html#benchmarks",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "Benchmarks",
    "text": "Benchmarks\nThe benchmarks are the same when I capture the date and time, similar to Sys.time in R. For example, when I run the Python code for \\(\\pi\\) approximation (same code as example) and benchmark it with time module for the first time, I got a difference of 17 seconds. Plus, the mark function from bench package is so precise that I use this package everytime when I benchmark the codes.\n\npi_approx_bm &lt;- bench::mark(\n  C = pi_approx_c(1e8),\n  Cpp = pi_approx_cpp(1e8),\n  Julia = pi_approx_jl(1e8),\n  Rust = pi_approx_rs(1e8),\n  FORTRAN = pi_approx_fortran(1e8),\n  R = pi_approx_r(1e8),\n  Python = pi_approx_py(1e8),\n  check = F\n)\npi_approx_bm\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C          163.62ms 168.01ms    5.55     16.46KB        0\n2 Cpp        160.68ms 168.41ms    5.92      7.67KB        0\n3 Julia      537.76ms 537.76ms    1.86      5.73KB        0\n4 Rust          1.37s    1.37s    0.728      4.8KB        0\n5 FORTRAN    151.77ms 152.62ms    6.56     16.46KB        0\n6 R            17.63s   17.63s    0.0567        0B        0\n7 Python       31.06s   31.06s    0.0322    4.98KB        0\n\npi_approx_bm |&gt; plot()\n\nLoading required namespace: tidyr\n\n\n\n\n\n\n\n\n\nFrom this result, we can say that the C++ is the fastest language among the 7 languages I selected for computing in using for loops, following with C and FORTRAN.",
    "crumbs": [
      "Home",
      "Approximating Pi",
      "Approximating $\\pi$"
    ]
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "I thought the outcome stays the same. Sometimes, when I make another run on approximating \\(\\pi\\), C is the fastest while sometimes FORTRAN is the fastest. Only if I make a Quarto Documentation out of this code, or otherwise, C++ is surely the fastest.\nThe remarks that I am sure for this example:\n\nR or Python shares the outcome: Being the slowest among them.\nThe Rust code is just not optimized.\n\nSame thing for other languages, especially Julia.\n\nC++ is the fastest in some application here.\n\nRecursive Fibonacci Sequence\n\n\nSo here’s my take:\n\nSurely that C++ code is only code that can make R code faster. Among the lower languages, C++ is the easiest language to compile but you need to write a boilerplate C++ code in order to work.\nFORTRAN code makes the solution the more boilerplate.\nUse vectorized operations or parallel computing to make the code more faster.",
    "crumbs": [
      "Home",
      "Conclusion",
      "Conclusion"
    ]
  },
  {
    "objectID": "conclusion.html#conclusion",
    "href": "conclusion.html#conclusion",
    "title": "FOR-LOOPS-ARCHIVE",
    "section": "",
    "text": "I thought the outcome stays the same. Sometimes, when I make another run on approximating \\(\\pi\\), C is the fastest while sometimes FORTRAN is the fastest. Only if I make a Quarto Documentation out of this code, or otherwise, C++ is surely the fastest.\nThe remarks that I am sure for this example:\n\nR or Python shares the outcome: Being the slowest among them.\nThe Rust code is just not optimized.\n\nSame thing for other languages, especially Julia.\n\nC++ is the fastest in some application here.\n\nRecursive Fibonacci Sequence\n\n\nSo here’s my take:\n\nSurely that C++ code is only code that can make R code faster. Among the lower languages, C++ is the easiest language to compile but you need to write a boilerplate C++ code in order to work.\nFORTRAN code makes the solution the more boilerplate.\nUse vectorized operations or parallel computing to make the code more faster.",
    "crumbs": [
      "Home",
      "Conclusion",
      "Conclusion"
    ]
  }
]