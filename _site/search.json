[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "In this activity, I show you the programming languages that can be used in computing with the use of for loops.\nNote that not all the programming languages are listed in this example because these are all the programming languages I know that can be exported into R.\nHere are the list of languages will be used in this activity:\n\nC\n\nC is maybe the easiest compiled language to learn. It is so easy to compile a C code into R.\n\nC++\n\nDespite its reputation for complexity, leveraging tools like Rcpp and its APIs makes writing C++ code more accessible. Plus, exporting C++ code into the R environment is a breeze, even I, who sometimes write a bad code, can write a C++ code and it is so easy to export a C++ code into R environment.\nCompared to C, compilation in C++ might take a bit longer due to various factors.\nwith the Rcpp namespace, you can seamlessly integrate C++ features like NumericVector and DataFrame, mirroring R’s class system.\n\nJulia\n\nJulia shares similarities with C in that it’s a compiled language, effectively addressing the “2 language problem” by eliminating the need for separate languages like C, C++, or FORTRAN APIs.\nJulia is able to be both fast and easy to read.\n\nRust\n\nRust, akin to C/C++, prioritizes memory safety.\nPreparing to compile Rust code in R involves installing necessary Build Tools and rustc cargo via the terminal.\n\nFORTRAN\n\nDespite its age, FORTRAN remains indispensable in the realm of computing, boasting speed comparable to C/C++.\nIt’s still widely used as source code for R packages, fAsianOptions as its example.\n\nR\n\nWhile maybe R isn’t exclusively utilized for computing, it’s a statistical computing language widely embraced in statistical analysis.\nWith R, it is so easy to conduct a pure data science like data manipulation and visulizations, thanks to the libraries, such as dplyr and ggplot2, and to integrate “structured” databases with DBI and dbplyr.\n\nPython\n\nPython is an effective general purpose language that can be even used in statistics or any fields of computing.\n\n\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. I only used those languages that can be both used in computing and listed in knitr."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "In this activity, I show you the programming languages that can be used in computing with the use of for loops.\nNote that not all the programming languages are listed in this example because these are all the programming languages I know that can be exported into R.\nHere are the list of languages will be used in this activity:\n\nC\n\nC is maybe the easiest compiled language to learn. It is so easy to compile a C code into R.\n\nC++\n\nDespite its reputation for complexity, leveraging tools like Rcpp and its APIs makes writing C++ code more accessible. Plus, exporting C++ code into the R environment is a breeze, even I, who sometimes write a bad code, can write a C++ code and it is so easy to export a C++ code into R environment.\nCompared to C, compilation in C++ might take a bit longer due to various factors.\nwith the Rcpp namespace, you can seamlessly integrate C++ features like NumericVector and DataFrame, mirroring R’s class system.\n\nJulia\n\nJulia shares similarities with C in that it’s a compiled language, effectively addressing the “2 language problem” by eliminating the need for separate languages like C, C++, or FORTRAN APIs.\nJulia is able to be both fast and easy to read.\n\nRust\n\nRust, akin to C/C++, prioritizes memory safety.\nPreparing to compile Rust code in R involves installing necessary Build Tools and rustc cargo via the terminal.\n\nFORTRAN\n\nDespite its age, FORTRAN remains indispensable in the realm of computing, boasting speed comparable to C/C++.\nIt’s still widely used as source code for R packages, fAsianOptions as its example.\n\nR\n\nWhile maybe R isn’t exclusively utilized for computing, it’s a statistical computing language widely embraced in statistical analysis.\nWith R, it is so easy to conduct a pure data science like data manipulation and visulizations, thanks to the libraries, such as dplyr and ggplot2, and to integrate “structured” databases with DBI and dbplyr.\n\nPython\n\nPython is an effective general purpose language that can be even used in statistics or any fields of computing.\n\n\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. I only used those languages that can be both used in computing and listed in knitr."
  },
  {
    "objectID": "index.html#approximating-pi",
    "href": "index.html#approximating-pi",
    "title": "Comparison of for loops from various programming languages",
    "section": "Approximating \\(\\pi\\)",
    "text": "Approximating \\(\\pi\\)\n\nCC++JuliaRustFORTRANRPythonBenchmarks\n\n\nIf your purpose is a language for computing within R, C is maybe easier than C++ but in order this to be working and exportable, the result of the computation is needed to store the memory address, a.k.a. the pointers.\n\n#include &lt;stdio.h&gt;\n\nvoid pi_approx_c(int *n, double *result) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; *n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  *result = 4 * pi_4;\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c cc204d7f6a1a.c -o cc204d7f6a1a.o\ngcc -shared -s -static-libgcc -o cc204d7f6a1a.dll tmp.def cc204d7f6a1a.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nIn order to natively call the C code into R, use .C and then extract the result via $res.\n\npi_approx_c &lt;- function(n) {\n  res &lt;- .C(\"pi_approx_c\", as.integer(n), res=numeric(1))$res\n  return(res)\n}\n\npi_approx_c(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, the C++ code is way similar to the C code except, we don’t need to use pointers in order the result to store its memory address. Like I said, using Rcpp, the C++ code is so easy to be exported, as long as its error-free.\nAfter compiling, you don’t need to call it and the pi_approx_cpp will be saved into R Global Environment directly.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble pi_approx_cpp(int n) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  return 4 * pi_4;\n}\n\n/***R\npi_approx_cpp(1e5)\n*/\n\n\n\nAs you can see, we only write few codes, unlike in C/C++, to approximate the \\(\\pi\\)\n\nfunction pi_approx_jl(n)\n    pi_4 = 0.0\n    sign = 1.0\n    for i in 1:n\n        pi_4 += sign / (2*i - 1)\n        sign *= -1\n    end\n    return 4 * pi_4\nend\n\npi_approx_jl (generic function with 1 method)\n\n\nWith JuliaCall, you can call the Julia function into R via julia_eval. But there are few other ways to call it, but I found julia_eval more convenient.\n\npi_approx_jl &lt;- JuliaCall::julia_eval(\"pi_approx_jl\")\npi_approx_jl(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, we use the extendr API to compile the Rust code into R, just like we did with Rcpp to compile the C++ code into R.\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn pi_approx_rs(n: i32) -&gt; f64 {\n    let mut pi_4 = 0.0;\n    let mut sign = 1.0;\n\n    for i in 0..n {\n        pi_4 += sign / (2 * i + 1) as f64;\n        sign *= -1.0;\n    }\n\n    4.0 * pi_4\n}\n\nAfter compiling, just like C++, the pi_approx_rs function in Rust will be saved into R Global Environment directly.\n\npi_approx_rs(1e5)\n\n[1] 3.141583\n\n\n\n\nMaybe FORTRAN is fast, but the solution is more boilerplate, although for me it is more readable compared to C/C++. Just like C, we need the result to be store in memory address.\nIf you use old FORTRAN version, you might need to CAPITALIZE the FORTRAN program. But we use the ’95 version of FORTRAN so we don’t need to CAPITALIZE the program.\n\nsubroutine pi_approx(n, result)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: result\n    integer :: i\n    real(8) :: pi_4, sign\n    \n    pi_4 = 0.0\n    sign = 1.0\n    \n    do i = 1, n\n        pi_4 = pi_4 + sign / (2 * i - 1)\n        sign = sign * (-1.0)\n    end do\n    \n    result = 4 * pi_4\nend subroutine pi_approx\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f95c204c327c.f95 -o f95c204c327c.o\ngcc -shared -s -static-libgcc -o f95c204c327c.dll tmp.def f95c204c327c.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nJust like C, but instead, in order to natively call the FORTRAN code into R, use .Fortran and then extract the result via $result.\n\npi_approx_fortran &lt;- function(n) {\n  result &lt;- .Fortran(\"pi_approx\", as.integer(n), result=double(1))$result\n  return(result)\n}\n\npi_approx_fortran(1e5)\n\n[1] 3.141583\n\n\n\n\nR is so close to be functional programming and to be Domain Specific Language (or DSL). It is so functional, you need to use &lt;- function() to define a function and I sometimes agree that this is ugly but hey it works! This is just my opinion.\nR is already a default language in RStudio, so the function we define is already callable in R Global Environment.\n\npi_approx_r &lt;- function(n) {\n  pi_4 &lt;- 0\n  sign &lt;- 1\n  \n  for (i in 1:n) {\n    pi_4 &lt;- pi_4 + sign / (2*i - 1)\n    sign &lt;- sign * -1\n  }\n  \n  return(4 * pi_4)\n}\n\npi_approx_r(1e5)\n\n[1] 3.141583\n\n\n\n\nR and Python has so much similarities, except Python is more onto general purpose language.\n\ndef pi_approx_py(n):\n    n = int(n)\n    pi_4 = 0\n    sign = 1\n    \n    for i in range(n):\n        pi_4 += sign / (2 * i + 1)\n        sign *= -1\n    return pi_4 * 4\n\nThe defined function in Python is also callable. Using py module in reticulate package, you can easily interact with any Python objects in Python module.\n\npi_approx_py &lt;- reticulate::py$pi_approx_py\npi_approx_py(1e5)\n\n[1] 3.141583\n\n\n\n\n\npi_approx_bm &lt;- bench::mark(\n  C = pi_approx_c(1e8),\n  Cpp = pi_approx_cpp(1e8),\n  Julia = pi_approx_jl(1e8),\n  Rust = pi_approx_rs(1e8),\n  FORTRAN = pi_approx_fortran(1e8),\n  R = pi_approx_r(1e8),\n  Python = pi_approx_py(1e8),\n  check = F\n)\npi_approx_bm\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C          150.52ms 151.57ms    6.60     16.46KB        0\n2 Cpp        150.39ms 151.11ms    6.62      7.67KB        0\n3 Julia      403.95ms  405.4ms    2.47      5.73KB        0\n4 Rust           1.1s     1.1s    0.906      4.8KB        0\n5 FORTRAN    151.32ms 151.86ms    6.58     16.46KB        0\n6 R             8.14s    8.14s    0.123         0B        0\n7 Python       16.12s   16.12s    0.0620    4.98KB        0\n\npi_approx_bm |&gt; plot()\n\nLoading required namespace: tidyr\n\n\n\n\n\n\n\n\n\nFrom this result, we can say that the C++ is the fastest language among the 7 languages I selected for computing in using for loops, following with C and FORTRAN."
  },
  {
    "objectID": "index.html#recursive-fibonacci-sequence",
    "href": "index.html#recursive-fibonacci-sequence",
    "title": "Comparison of for loops from various programming languages",
    "section": "Recursive Fibonacci Sequence",
    "text": "Recursive Fibonacci Sequence\nSame procedure as approximating the \\(\\pi\\), compile and then compile\n\nCC++JuliaRustFORTRANRPythonBenchmarks\n\n\n\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt;\n\nvoid fib_c(int *n, int *seq) {\n    seq[0] = 0;\n    if (*n &gt; 0) {\n        seq[1] = 1;\n        for (int i = 2; i &lt;= *n; ++i) {\n            seq[i] = seq[i - 1] + seq[i - 2];\n        }\n    }\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c cc205897abf.c -o cc205897abf.o\ngcc -shared -s -static-libgcc -o cc205897abf.dll tmp.def cc205897abf.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_c &lt;- function(n) {\n  seq &lt;- integer(n + 1)\n  .C(\"fib_c\", n = as.integer(n), seq = as.integer(seq))$seq\n}\nfib_c(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector fib_cpp(int n){\n  IntegerVector fibSequence(n + 1);\n  fibSequence[0] = 0;\n  if (n &gt; 1) {\n    fibSequence[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n  }\n  return fibSequence;\n  \n}\n\n\n/***R\nfib_cpp(10)\n*/\n\n\n\n\nfunction fib_jl(n::Int)\n  fib = Int[]\n  push!(fib, 0)  \n  push!(fib, 1)  \n  \n  \n  for i in 3:n\n      push!(fib, fib[i - 1] + fib[i - 2])  \n  end\n  \n  return fib\nend\n\nfib_jl (generic function with 1 method)\n\n\n\nfib_jl &lt;- JuliaCall::julia_eval(\"fib_jl\")\nfib_jl(10L)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\n\n\n\nuse extendr_api::prelude::*;\nuse std::collections::HashMap;\n\nfn fibonacci(n: i32, memo: &mut HashMap&lt;i32, i32&gt;) -&gt; i32 {\n    if let Some(&result) = memo.get(&n) {\n        return result;\n    }\n\n    let result = if n &lt;= 1 {\n        n\n    } else {\n        fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    };\n\n    memo.insert(n, result);\n    result\n}\n\n#[extendr]\nfn fib_rs(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut sequence = vec![];\n    let mut memo = HashMap::new();\n\n    for i in 0..n + 1 {\n        sequence.push(fibonacci(i, &mut memo));\n    }\n\n    sequence\n}\n\n\nfib_rs(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nsubroutine fib_f(n, fib)\n    integer, intent(in) :: n\n    integer, intent(out) :: fib(n)\n    integer :: i\n    \n    fib(1) = 0\n    fib(2) = 1\n\n    do i = 3, n + 1\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\nend subroutine fib_f\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f95c2049a7942.f95 -o f95c2049a7942.o\ngcc -shared -s -static-libgcc -o f95c2049a7942.dll tmp.def f95c2049a7942.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_fortran &lt;- function(n) {\n  n &lt;- n + 1\n  .Fortran(\"fib_f\", as.integer(n), fib = integer(n))$fib\n}\nfib_fortran(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nfib_r &lt;- function(n) {\n  fib &lt;- integer(n + 1)\n  fib[1] &lt;- 0\n  fib[2] &lt;- 1\n  for (i in 3:(n+1)) {\n    fib[i] &lt;- fib[i - 1] + fib[i - 2]\n  }\n  return(fib)\n}\n\nfib_r(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\ndef fib_p(n):\n    n = int(n)\n    fib_seq = [0, 1]\n    for i in range(2, n + 1):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\n\nfib_py &lt;- reticulate::py$fib_p\nfib_py(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nbench::mark(\n  C = fib_c(40),\n  Cpp = fib_cpp(40),\n  Julia = fib_jl(41L),\n  Rust = fib_rs(40),\n  FORTRAN = fib_fortran(40),\n  R = fib_r(40),\n  Python = fib_py(40),\n  check = F\n)\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C             2.5µs    2.8µs   226178.   19.23KB     0   \n2 Cpp           1.5µs    1.7µs   331179.    6.84KB    33.1 \n3 Julia          10µs   10.5µs    88674.    4.89KB     0   \n4 Rust         67.7µs   69.7µs    13414.    5.02KB     0   \n5 FORTRAN       2.7µs      3µs   272638.   17.73KB     0   \n6 R             7.4µs    8.1µs   109332.      592B     0   \n7 Python         52µs   54.4µs    16308.     5.2KB     2.07"
  },
  {
    "objectID": "index.html#conclusion",
    "href": "index.html#conclusion",
    "title": "Comparison of for loops from various programming languages",
    "section": "Conclusion",
    "text": "Conclusion\nI thought the outcome stays the same. Sometimes, when I make another run on approximating \\(\\pi\\), C is the fastest while sometimes FORTRAN is the fastest. Only if I make a Quarto Documentation out of this code, or otherwise, C++ is surely the fastest.\nThe outcome that I am sure for this example:\n\nR or Python shares the outcome: Being the slowest among them.\nThe Rust code is just not optimized.\nC++ is the fastest in some application here.\n\nRecursive Fibonacci Sequence\n\n\nSo here’s my take:\n\nSurely that C++ code is only code that can make R code faster.\nFORTRAN code makes the solution more boilerplate unless you want a more boilerplate codes.\nUse vectorized operations or parallel computing to make the code more faster.\nIn Data Science, it is more advisable to use libraries that are more optimized, such as sklearn, tidymodels, etc…"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]