[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "In this activity, I show you the programming languages that can be used in computing with the use of for loops.\nNote that not all the programming languages are listed in this example because these are all the programming languages I know that can be exported into R.\nHere are the list of languages will be used in this activity:\n\nC\n\nC is maybe the easiest compiled language to learn. It is so easy to compile a C code into R.\n\nC++\n\nDespite its reputation for complexity, leveraging tools like Rcpp and its APIs makes writing C++ code more accessible. Plus, exporting C++ code into the R environment is a breeze, even I, who sometimes write a bad code, can write a C++ code and it is so easy to export a C++ code into R environment.\nCompared to C, compilation in C++ might take a bit longer due to various factors.\nwith the Rcpp namespace, you can seamlessly integrate C++ features like NumericVector and DataFrame, mirroring R’s class system.\n\nJulia\n\nJulia shares similarities with C in that it’s a compiled language, effectively addressing the “2 language problem” by eliminating the need for separate languages like C, C++, or FORTRAN APIs.\nJulia is a JIT compiled and it is able to be both fast and easy to read.\n\nRust\n\nRust, akin to C/C++, prioritizes memory safety.\nPreparing to compile Rust code in R involves installing necessary Build Tools and rustc cargo via the terminal.\n\nFORTRAN\n\nDespite its age, FORTRAN remains indispensable in the realm of computing, boasting speed comparable to C/C++.\nIt’s still widely used as source code for R packages, fAsianOptions as its example.\n\nR\n\nWhile maybe R isn’t exclusively utilized for computing, it’s a statistical computing language widely embraced in statistical analysis.\nWith R, it is so easy to conduct a pure data science like data manipulation and visulizations, thanks to the libraries, such as dplyr and ggplot2, and to integrate “structured” databases with DBI and dbplyr.\n\nPython\n\nPython is an effective general purpose language that can be even used in statistics or any fields of computing.\n\n\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. I only used those languages that can be both used in computing and listed in knitr. Also, I wrapped the codes from other languages so that it would be easy for me to benchmark them with bench::time."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "In this activity, I show you the programming languages that can be used in computing with the use of for loops.\nNote that not all the programming languages are listed in this example because these are all the programming languages I know that can be exported into R.\nHere are the list of languages will be used in this activity:\n\nC\n\nC is maybe the easiest compiled language to learn. It is so easy to compile a C code into R.\n\nC++\n\nDespite its reputation for complexity, leveraging tools like Rcpp and its APIs makes writing C++ code more accessible. Plus, exporting C++ code into the R environment is a breeze, even I, who sometimes write a bad code, can write a C++ code and it is so easy to export a C++ code into R environment.\nCompared to C, compilation in C++ might take a bit longer due to various factors.\nwith the Rcpp namespace, you can seamlessly integrate C++ features like NumericVector and DataFrame, mirroring R’s class system.\n\nJulia\n\nJulia shares similarities with C in that it’s a compiled language, effectively addressing the “2 language problem” by eliminating the need for separate languages like C, C++, or FORTRAN APIs.\nJulia is a JIT compiled and it is able to be both fast and easy to read.\n\nRust\n\nRust, akin to C/C++, prioritizes memory safety.\nPreparing to compile Rust code in R involves installing necessary Build Tools and rustc cargo via the terminal.\n\nFORTRAN\n\nDespite its age, FORTRAN remains indispensable in the realm of computing, boasting speed comparable to C/C++.\nIt’s still widely used as source code for R packages, fAsianOptions as its example.\n\nR\n\nWhile maybe R isn’t exclusively utilized for computing, it’s a statistical computing language widely embraced in statistical analysis.\nWith R, it is so easy to conduct a pure data science like data manipulation and visulizations, thanks to the libraries, such as dplyr and ggplot2, and to integrate “structured” databases with DBI and dbplyr.\n\nPython\n\nPython is an effective general purpose language that can be even used in statistics or any fields of computing.\n\n\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. I only used those languages that can be both used in computing and listed in knitr. Also, I wrapped the codes from other languages so that it would be easy for me to benchmark them with bench::time."
  },
  {
    "objectID": "index.html#approximating-pi",
    "href": "index.html#approximating-pi",
    "title": "Comparison of for loops from various programming languages",
    "section": "Approximating \\(\\pi\\)",
    "text": "Approximating \\(\\pi\\)\nIt took hundreds of years to precisely approximate the \\(\\pi\\).\nI used the Leibniz formula to approximate \\(\\pi\\). It came from an alternating series, a power series of \\(\\frac{1}{x^2+1}\\).\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 0}^{\\infty} {\\frac{(-1)^k}{2k + 1}}\n\\]\nWe need to adjust a little bit for the programming languages that starts with index-1, like R, Julia and FORTRAN.\nThis is how Leibniz formula looks like:\n\\[\n\\pi=4\\sum_{k = 1}^{\\infty} {\\frac{(-1)^k}{2k - 1}}\n\\]\n\nCC++JuliaRustFORTRANRPythonBenchmarks\n\n\nIf your purpose is a language for fast computation within R, C is maybe easier than C++ but in order this to be working and exportable, the inputs and outputs of the computation were stored in the memory address, a.k.a. the pointers.\n\n#include &lt;stdio.h&gt;\n\nvoid pi_approx_c(int *n, double *result) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; *n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  *result = 4 * pi_4;\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c185471b0210.c -o c185471b0210.o\ngcc -shared -s -static-libgcc -o c185471b0210.dll tmp.def c185471b0210.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nIn order to wrap the C code into R, use .C and then extract the result via $res.\n\npi_approx_c &lt;- function(n) {\n  res &lt;- .C(\"pi_approx_c\", as.integer(n), res=numeric(1))$res\n  return(res)\n}\n\npi_approx_c(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, the C++ code is way similar to the C code except, we don’t need to use pointers in order share the results in a memory address, instead we only write the C++ code in a standard way. Like I said, using Rcpp, the C++ code is so easy to be exported, as long as we made it to be error-free.\nAfter compiling, the pi_approx_cpp function will be exported by // [[Rcpp::export]] attributes and saved into R Global Environment directly.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble pi_approx_cpp(int n) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 0; i &lt; n; i++) {\n    pi_4 += sign / (2 * i + 1);\n    sign *= -1;\n  }\n  \n  return 4 * pi_4;\n}\n\n/***R\npi_approx_cpp(1e5)\n*/\n\n\n\nAs you can see, we only write few codes, unlike in C/C++, to approximate the \\(\\pi\\)\n\nfunction pi_approx_jl(n)\n    pi_4 = 0.0\n    sign = 1.0\n    for i in 1:n\n        pi_4 += sign / (2*i - 1)\n        sign *= -1\n    end\n    return 4 * pi_4\nend\n\npi_approx_jl (generic function with 1 method)\n\n\nWith JuliaCall, you can wrap the Julia function into R via julia_eval. But there are few other ways to call it, but I found julia_eval more convenient.\n(Note: If you are already familiar with reticulate, this is the same as py_eval)\n\npi_approx_jl &lt;- JuliaCall::julia_eval(\"pi_approx_jl\")\npi_approx_jl(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, we use the extendr and #[extendr] attribute API to write a Rust code and compile it into R, just like we did with Rcpp to compile the C++ code into R\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn pi_approx_rs(n: i32) -&gt; f64 {\n    let mut pi_4 = 0.0;\n    let mut sign = 1.0;\n\n    for i in 0..n {\n        pi_4 += sign / (2 * i + 1) as f64;\n        sign *= -1.0;\n    }\n\n    4.0 * pi_4\n}\n\nAfter compiling, just like C++, the pi_approx_rs function in Rust will be wrapped and saved into R Global Environment directly.\n\npi_approx_rs(1e5)\n\n[1] 3.141583\n\n\n\n\nMaybe FORTRAN is fast, but the solution is more boilerplate, although for me it is more readable compared to C/C++. Just like C, we need the result to be store in memory address.\nIf you use old FORTRAN version, you might need to CAPITALIZE the FORTRAN program. But we use the ’95 version of FORTRAN so we don’t need to CAPITALIZE the program.\n\nsubroutine pi_approx(n, result)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: result\n    integer :: i\n    real(8) :: pi_4, sign\n    \n    pi_4 = 0.0\n    sign = 1.0\n    \n    do i = 1, n\n        pi_4 = pi_4 + sign / (2 * i - 1)\n        sign = sign * (-1.0)\n    end do\n    \n    result = 4 * pi_4\nend subroutine pi_approx\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f9518542ef967ec.f95 -o f9518542ef967ec.o\ngcc -shared -s -static-libgcc -o f9518542ef967ec.dll tmp.def f9518542ef967ec.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nJust like C, but instead, in order to natively call the FORTRAN code into R, use .Fortran and then extract the result via $result.\n\npi_approx_fortran &lt;- function(n) {\n  result &lt;- .Fortran(\"pi_approx\", as.integer(n), result=double(1))$result\n  return(result)\n}\n\npi_approx_fortran(1e5)\n\n[1] 3.141583\n\n\n\n\nR is so close to be functional programming and to be Domain Specific Language (or DSL). It is so functional, you need to use &lt;- function() to define a function and I sometimes agree that this is ugly but hey it works! This is just my opinion.\nR is already a default language in RStudio, so the function we define is already callable in R Global Environment.\n\npi_approx_r &lt;- function(n) {\n  pi_4 &lt;- 0\n  sign &lt;- 1\n  \n  for (i in 1:n) {\n    pi_4 &lt;- pi_4 + sign / (2*i - 1)\n    sign &lt;- sign * -1\n  }\n  \n  return(4 * pi_4)\n}\n\npi_approx_r(1e5)\n\n[1] 3.141583\n\n\n\n\nR and Python has so much similarities, except Python is more onto general purpose language.\n\ndef pi_approx_py(n):\n    n = int(n)\n    pi_4 = 0\n    sign = 1\n    \n    for i in range(n):\n        pi_4 += sign / (2 * i + 1)\n        sign *= -1\n    return pi_4 * 4\n\nThe defined function in Python is also callable. Using py module in reticulate package, you can easily interact with any Python objects in Python module.\n\npi_approx_py &lt;- reticulate::py$pi_approx_py\npi_approx_py(1e5)\n\n[1] 3.141583\n\n\n\n\nThe benchmarks are the same when I capture the date and time, similar to Sys.time in R. For example, when I run the Python code for \\(\\pi\\) approximation (same code as example) and benchmark it with time module for the first time, I got a difference of 17 seconds. Plus, the mark function from bench package is so precise that I use this package everytime when I benchmark the codes.\n\npi_approx_bm &lt;- bench::mark(\n  C = pi_approx_c(1e8),\n  Cpp = pi_approx_cpp(1e8),\n  Julia = pi_approx_jl(1e8),\n  Rust = pi_approx_rs(1e8),\n  FORTRAN = pi_approx_fortran(1e8),\n  R = pi_approx_r(1e8),\n  Python = pi_approx_py(1e8),\n  check = F\n)\npi_approx_bm\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C          149.03ms 150.46ms    6.64     16.46KB        0\n2 Cpp        149.37ms 150.53ms    6.65      7.67KB        0\n3 Julia      405.06ms 406.75ms    2.46      5.73KB        0\n4 Rust          1.13s    1.13s    0.885      4.8KB        0\n5 FORTRAN    148.76ms 149.78ms    6.67     16.46KB        0\n6 R             9.91s    9.91s    0.101         0B        0\n7 Python       20.06s   20.06s    0.0499    4.98KB        0\n\npi_approx_bm |&gt; plot()\n\nLoading required namespace: tidyr\n\n\n\n\n\n\n\n\n\nFrom this result, we can say that the C++ is the fastest language among the 7 languages I selected for computing in using for loops, following with C and FORTRAN."
  },
  {
    "objectID": "index.html#recursive-fibonacci-sequence",
    "href": "index.html#recursive-fibonacci-sequence",
    "title": "Comparison of for loops from various programming languages",
    "section": "Recursive Fibonacci Sequence",
    "text": "Recursive Fibonacci Sequence\nSame procedure as approximating the \\(\\pi\\), compile and then compile\n\nCC++JuliaRustFORTRANRPythonBenchmarks\n\n\n\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt;\n\nvoid fib_c(int *n, int *seq) {\n    seq[0] = 0;\n    if (*n &gt; 0) {\n        seq[1] = 1;\n        for (int i = 2; i &lt;= *n; ++i) {\n            seq[i] = seq[i - 1] + seq[i - 2];\n        }\n    }\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c18545d9423aa.c -o c18545d9423aa.o\ngcc -shared -s -static-libgcc -o c18545d9423aa.dll tmp.def c18545d9423aa.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_c &lt;- function(n) {\n  seq &lt;- integer(n + 1)\n  .C(\"fib_c\", n = as.integer(n), seq = as.integer(seq))$seq\n}\nfib_c(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector fib_cpp(int n){\n  IntegerVector fibSequence(n + 1);\n  fibSequence[0] = 0;\n  if (n &gt; 1) {\n    fibSequence[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n  }\n  return fibSequence;\n  \n}\n\n\n/***R\nfib_cpp(10)\n*/\n\n\n\n\nfunction fib_jl(n::Int)\n  fib = Int[]\n  push!(fib, 0)  \n  push!(fib, 1)  \n  \n  \n  for i in 3:n\n      push!(fib, fib[i - 1] + fib[i - 2])  \n  end\n  \n  return fib\nend\n\nfib_jl (generic function with 1 method)\n\n\n\nfib_jl &lt;- JuliaCall::julia_eval(\"fib_jl\")\nfib_jl(10L)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\n\n\n\nuse extendr_api::prelude::*;\nuse std::collections::HashMap;\n\nfn fibonacci(n: i32, memo: &mut HashMap&lt;i32, i32&gt;) -&gt; i32 {\n    if let Some(&result) = memo.get(&n) {\n        return result;\n    }\n\n    let result = if n &lt;= 1 {\n        n\n    } else {\n        fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    };\n\n    memo.insert(n, result);\n    result\n}\n\n#[extendr]\nfn fib_rs(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut sequence = vec![];\n    let mut memo = HashMap::new();\n\n    for i in 0..n + 1 {\n        sequence.push(fibonacci(i, &mut memo));\n    }\n\n    sequence\n}\n\n\nfib_rs(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nsubroutine fib_f(n, fib)\n    integer, intent(in) :: n\n    integer, intent(out) :: fib(n)\n    integer :: i\n    \n    fib(1) = 0\n    fib(2) = 1\n\n    do i = 3, n + 1\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\nend subroutine fib_f\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f9518543ce8ee0.f95 -o f9518543ce8ee0.o\ngcc -shared -s -static-libgcc -o f9518543ce8ee0.dll tmp.def f9518543ce8ee0.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_fortran &lt;- function(n) {\n  n &lt;- n + 1\n  .Fortran(\"fib_f\", as.integer(n), fib = integer(n))$fib\n}\nfib_fortran(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nfib_r &lt;- function(n) {\n  fib &lt;- integer(n + 1)\n  fib[1] &lt;- 0\n  fib[2] &lt;- 1\n  for (i in 3:(n+1)) {\n    fib[i] &lt;- fib[i - 1] + fib[i - 2]\n  }\n  return(fib)\n}\n\nfib_r(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\ndef fib_p(n):\n    n = int(n)\n    fib_seq = [0, 1]\n    for i in range(2, n + 1):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\n\nfib_py &lt;- reticulate::py$fib_p\nfib_py(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nbench::mark(\n  C = fib_c(40),\n  Cpp = fib_cpp(40),\n  Julia = fib_jl(41L),\n  Rust = fib_rs(40),\n  FORTRAN = fib_fortran(40),\n  R = fib_r(40),\n  Python = fib_py(40),\n  check = F\n)\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C             2.5µs    2.8µs   218149.   19.23KB     21.8\n2 Cpp           1.5µs    1.8µs   276748.    6.84KB      0  \n3 Julia        10.1µs   10.9µs    83730.    4.89KB      0  \n4 Rust         67.9µs   69.7µs    13241.    5.02KB      0  \n5 FORTRAN       2.7µs      3µs   279491.   17.73KB      0  \n6 R             7.8µs    8.8µs    97832.      592B      0  \n7 Python       51.6µs   55.5µs    15556.     5.2KB      0"
  },
  {
    "objectID": "index.html#monte-carlo-estimation",
    "href": "index.html#monte-carlo-estimation",
    "title": "Comparison of for loops from various programming languages",
    "section": "Monte Carlo Estimation",
    "text": "Monte Carlo Estimation\nBuffon needles\n::: {.panel-tabset group=“language”}\n\nC\n\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt;\n\nvoid fib_c(int *n, int *seq) {\n    seq[0] = 0;\n    if (*n &gt; 0) {\n        seq[1] = 1;\n        for (int i = 2; i &lt;= *n; ++i) {\n            seq[i] = seq[i - 1] + seq[i - 2];\n        }\n    }\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c18542ec77e28.c -o c18542ec77e28.o\ngcc -shared -s -static-libgcc -o c18542ec77e28.dll tmp.def c18542ec77e28.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_c &lt;- function(n) {\n  seq &lt;- integer(n + 1)\n  .C(\"fib_c\", n = as.integer(n), seq = as.integer(seq))$seq\n}\nfib_c(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\nC++\n\n#include &lt;Rcpp.h&gt;\n#include &lt;random&gt;\n#include &lt;cmath&gt;\n\n// [[Rcpp::depends(Rcpp)]]\n\nusing namespace Rcpp;\n\n// Function to estimate pi using Buffon's needle experiment\n// [[Rcpp::export]]\ndouble estimatePi(double n) {\n    double l = 0.9;\n    double p = 0;\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution&lt;double&gt; dis_angle(0.0, 360.0);\n    std::uniform_real_distribution&lt;double&gt; dis_x(0.0, 1.0);\n\n    for (long i = 0; i &lt; n; i++) {\n        double k = dis_angle(gen);  // random angle\n        double x = dis_x(gen);      // random x (0 to 1)\n        double y = (l / 2) * sin(k * M_PI / 180);  // Convert angle to radians\n\n        if (x &lt;= y) {\n            p++;  // Increment only if the condition is met\n        }\n    }\n\n    double pi = n / p;  // Divide by p, not l\n\n    return pi;\n}\n\n\n\nJulia\n\nfunction fib_jl(n::Int)\n  fib = Int[]\n  push!(fib, 0)  \n  push!(fib, 1)  \n  \n  \n  for i in 3:n\n      push!(fib, fib[i - 1] + fib[i - 2])  \n  end\n  \n  return fib\nend\n\nfib_jl (generic function with 1 method)\n\n\n\nfib_jl &lt;- JuliaCall::julia_eval(\"fib_jl\")\nfib_jl(10L)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\n\n\nRust\n\nuse extendr_api::prelude::*;\nuse std::collections::HashMap;\n\nfn fibonacci(n: i32, memo: &mut HashMap&lt;i32, i32&gt;) -&gt; i32 {\n    if let Some(&result) = memo.get(&n) {\n        return result;\n    }\n\n    let result = if n &lt;= 1 {\n        n\n    } else {\n        fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    };\n\n    memo.insert(n, result);\n    result\n}\n\n#[extendr]\nfn fib_rs(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut sequence = vec![];\n    let mut memo = HashMap::new();\n\n    for i in 0..n + 1 {\n        sequence.push(fibonacci(i, &mut memo));\n    }\n\n    sequence\n}\n\n\nfib_rs(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\nFORTRAN\n\nsubroutine fib_f(n, fib)\n    integer, intent(in) :: n\n    integer, intent(out) :: fib(n)\n    integer :: i\n    \n    fib(1) = 0\n    fib(2) = 1\n\n    do i = 3, n + 1\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\nend subroutine fib_f\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f951854c1ccb2.f95 -o f951854c1ccb2.o\ngcc -shared -s -static-libgcc -o f951854c1ccb2.dll tmp.def f951854c1ccb2.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_fortran &lt;- function(n) {\n  n &lt;- n + 1\n  .Fortran(\"fib_f\", as.integer(n), fib = integer(n))$fib\n}\nfib_fortran(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\nR\n\nfib_r &lt;- function(n) {\n  fib &lt;- integer(n + 1)\n  fib[1] &lt;- 0\n  fib[2] &lt;- 1\n  for (i in 3:(n+1)) {\n    fib[i] &lt;- fib[i - 1] + fib[i - 2]\n  }\n  return(fib)\n}\n\nfib_r(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\nPython\n\ndef fib_p(n):\n    n = int(n)\n    fib_seq = [0, 1]\n    for i in range(2, n + 1):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\n\nfib_py &lt;- reticulate::py$fib_p\nfib_py(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\nBenchmarks\n\nbench::mark(\n  C = fib_c(40),\n  Cpp = fib_cpp(40),\n  Julia = fib_jl(41L),\n  Rust = fib_rs(40),\n  FORTRAN = fib_fortran(40),\n  R = fib_r(40),\n  Python = fib_py(40),\n  check = F\n)\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C             2.5µs    2.9µs   287706.   19.23KB     0   \n2 Cpp           1.5µs    1.9µs   245997.     2.7KB    24.6 \n3 Julia         9.9µs   10.7µs    75446.    4.89KB     0   \n4 Rust         67.5µs   69.1µs    13341.    5.02KB     0   \n5 FORTRAN       2.7µs      3µs   268381.   17.73KB     0   \n6 R             7.9µs    8.8µs    93616.      592B     0   \n7 Python       51.3µs   53.9µs    16097.     5.2KB     2.07"
  },
  {
    "objectID": "index.html#conclusion",
    "href": "index.html#conclusion",
    "title": "Comparison of for loops from various programming languages",
    "section": "Conclusion",
    "text": "Conclusion\nI thought the outcome stays the same. Sometimes, when I make another run on approximating \\(\\pi\\), C is the fastest while sometimes FORTRAN is the fastest. Only if I make a Quarto Documentation out of this code, or otherwise, C++ is surely the fastest.\nThe remarks that I am sure for this example:\n\nR or Python shares the outcome: Being the slowest among them.\nThe Rust code is just not optimized.\n\nSame thing for other languages, especially Julia.\n\nC++ is the fastest in some application here.\n\nRecursive Fibonacci Sequence\n\n\nSo here’s my take:\n\nSurely that C++ code is only code that can make R code faster. Among the lower languages, C++ is the easiest language to compile but you need to write a boilerplate C++ code in order to work.\nFORTRAN code makes the solution the more boilerplate.\nUse vectorized operations or parallel computing to make the code more faster."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]